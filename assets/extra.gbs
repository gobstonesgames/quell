/* ============================================================================================================
   START Babel.gbs
   Code for swap between  errors messages on different languages
   ============================================================================================================
*/
function language() { return(English) }

procedure Assert_OrFail_(condition, msg) { if (not condition) { BOOM(msg) } }
procedure ClearBoard()  { VaciarTablero() }

// ---------
// Internationalization
// ---------
type Language is variant {
  case English {}
  case Spanish {}
}

function babel(msgEn, msgSp) { 
  return(matching (language()) select 
           msgSp on Spanish
           msgEn otherwise)
}
/* ============================================================================================================
   END Babel.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START EnglishPrimitives.gbs
   Code for using English names on Gobstones programs, even when the language is still not internationalized
// REQUIRE: Babel.gbs
   ============================================================================================================
*/
// ---------
// Colors
// ---------
type Colour is variant {
    case Red    {}
    case Green  {}
    case Blue   {}
    case Black  {}
}

function colorEn2Sp(color) {
  return(matching (color) select
           Rojo   on Red
           Verde  on Green
           Azul   on Blue
           Negro  on Black
           boom(msgNotExpected("Colour")) otherwise)
}

function colorSp2En(color) {
  return(matching (color) select
           Red   on Rojo    
           Green on Verde   
           Blue  on Azul   
           Black on Negro
           boom(msgNotExpected("Color")) otherwise)
}

function hasStones(color) { return(hayBolitas(colorEn2Sp(color))) }
function numStones(color) { return(nroBolitas(colorEn2Sp(color))) }

procedure Drop(color) { Poner(colorEn2Sp(color)) }
procedure Grab(color) { 
    Assert_OrFail_(hasStones(color), msgNoStones())
    Sacar(colorEn2Sp(color)) 
}

function nextColor(color)  { return(colorSp2En(siguiente(colorEn2Sp(dir)))) }
function prevColor(color)  { return(colorSp2En(previo(colorEn2Sp(dir))))    }

function minColour() { return(colorSp2En(minColor())) }
function maxColour() { return(colorSp2En(maxColor())) }

// ---------
// Directions
// ---------
type Direction is variant {
    case North {}
    case East  {}
    case South {}
    case West  {}
}

function dirEn2Sp(dir) {
  return(matching (dir) select
           Norte on North
           Este  on East
           Sur   on South
           Oeste on West
           boom(msgNotExpected("Direction")) otherwise)
}

function dirSp2En(dir) {
  return(matching (dir) select
           North on Norte
           East  on Este 
           South on Sur  
           West  on Oeste
           boom(msgNotExpected("Dirección")) otherwise)
}

function canMove(dir) { return(puedeMover(dirEn2Sp(dir))) }

procedure Move(dir) { 
  Assert_OrFail_(canMove(dir), msgNoCells())
  Mover(dirEn2Sp(dir))     
}

procedure GoToEdge(dir) { IrAlBorde(dirEn2Sp(dir)) }

function opposite(dir) { return(dirSp2En(opuesto(dirEn2Sp(dir))))   }
function nextDir(dir)  { return(dirSp2En(siguiente(dirEn2Sp(dir)))) }
function prevDir(dir)  { return(dirSp2En(previo(dirEn2Sp(dir))))    }

function minDirection() { return(dirSp2En(minDir())) }
function maxDirection() { return(dirSp2En(maxDir())) }

// ---------
// Lists
// ---------
function isEmpty(xs) { return(esVacía(xs)) }
function head(xs)    { return(primero(xs)) }
function tail(xs)    { return(resto(xs))   }

// ---------
// ERROR MESSAGES
// ---------
function msgNoStones() { 
  return(babel("Cannot grab stones: there are no stones of that color"
              ,"No puedo sacar bolitas: no hay bolitas de ese color"
              ))
}

function msgNoCells() { 
  return(babel("Cannot move: there are no cells on that direction"
              ,"No puedo mover hacia ahí: no hay celdas en esa dirección"
              ))
}

function msgNotExpected(element) { 
  return(babel("CANNOT HAPPEN: has some element changed?"
              ,"NO PUEDE SUCEDER: ¿cambió algún elemento?"
              ))
}
/* ============================================================================================================
   END EnglishPrimitives.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Prelude.gbs
   General useful operations for a number of conveniencies
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
   ============================================================================================================
*/

// ---------
// Gobstones auxiliary functions
// ---------
procedure GoToCorner__(dir1, dir2) {
  /* PRECOND:
      * dir1 and dir2 are not equal and not opposite of each other
  */                                            
  GoToEdge(dir1)
  GoToEdge(dir2)
}

procedure Drop__Times(color, num) { repeat (num) { Drop(color) } }
procedure Grab__Times(color, num) { repeat (num) { Grab(color) } }
procedure Move__Times(dir, num)   { repeat (num) { Move(dir)   } }

procedure GrabAll(color) { Grab__Times(color, numStones(color)) }
procedure ClearCell() { foreach color in [minColour()..maxColour()] { GrabAll(color) } }

function isHorizontal(dir) { return (dir==East  || dir==West)  }
function isVertical(dir)   { return (dir==North || dir==South) }

function adjust_To_(val, max)             { return ((val+max) mod max) }
function num_IsBetween_And_(n, low, high) { return(n>=low && n<=high)  }

function delta(b) {
  return (choose 1 when (b)
                 0 otherwise) 
}

// ---------
// Math functions 
// ---------
function timesOf_In_(p,n) {
  currentN     := n
  currentTimes := 0
  while (currentN>=p) {
    currentTimes := currentTimes + 1
    currentN     := currentN-p
  }
  return (currentTimes)
}

function maxPowerOf_LessThan_(n, m) {
   currentPow := 1
   while (currentPow <= m) {
      currentPow := currentPow * n
   }
   return (currentPow div n)
}

function maxPowerOf_WithAccumPowLessThan_(n, p) {
   currentPow := 1
   currentSum := currentPow
   while (currentSum <= p) {
        currentPow := currentPow * n
        currentSum := currentPow + currentSum
    }
   return (currentPow div n)
}

// ---------
// Coding functions 
// ---------

// Dir
procedure DrawDir_With_(dir, color) { Drop__Times(color, codeOfDir_(dir)) }
function codeOfDir_(dir) {
  return (matching (dir) select
            1 on North
            2 on East
            3 on South
            4 on West
            boom(msgNotExpected("Direction")) otherwise)
}

function currentDirWith_(color) {
  /* PRECOND: * there is a Dir represented (between 1 to 4 color stones) */
  return(decodedDir_(numStones(color)))
}

function decodedDir_(code) {
  /* PRECOND: * code is the coding of a Dir (between 1 and 4) */
  return(matching (code) select
           North on 1
           East  on 2
           South on 3
           West  on 4
           boom(msgNotACodeFor_("Direction")) otherwise)
}

// Num
procedure DrawNum_With_(n, color) { Drop__Times(color, n)    }
function  currentNumWith_(color)  { return(numStones(color)) }

// Bool
procedure DrawBool_With_(b, color) { Drop__Times(color, codeOfBool_(b)) }
function  codeOfBool_(b) {
  return (choose 1 when (b)
                 0 otherwise)
}

function currentBoolWith_(color) {
  /* PRECOND: * there is a bool represented in the current cell with the given color */
  return(decodedBool_(numStones(color)))
}

function decodedBool_(code) {
  /* PRECOND: * code is the coding of a Bool (either 0 or 1) */
  return(matching (code) select
           True   on 1
           False  on 0
           boom(msgNotACodeFor_("Bool")) otherwise)
}

function codeOfDirs_(dirs) {
  /* OBS: the coding is a 0-less one */
  currentCode := 0
  currentPow  := 1
  foreach dir in dirs {
    currentCode := currentCode + currentPow * codeOfDir_(dir)
    currentPow  := currentPow * 4
  }
  return (currentCode)
}
                
function decodedDirs_(code) {
   /* OBS: for decoding, 0-s need to be adjusted */
   curCodes   := []
   currentPow := maxPowerOf_WithAccumPowLessThan_(4, code)
   remCode    := code
   while (currentPow > 0) { // (code-remCode) is encoded in curCodes (shifted by currentPow)
     curCode    := timesOf_In_(currentPow, remCode)
     if (curCode == 0) { // As a code digit cannot be 0, 1 must be substracted of previous calculus
         curCodes := substractOneFromDirCodes_(curCodes)
         remCode  := remCode + currentPow * 4 // remCode needs adjustment too, to keep the invariant
         curCode  := 4
     }
     remCode    := remCode - (curCode * currentPow)
     currentPow := currentPow div 4
     curCodes      := [ curCode ] ++ curCodes
   }
   return(mapDecodeDirsTo_(curCodes))
}

function mapDecodeDirsTo_(codes) {
  currentRes := []
  foreach code in codes {
    currentRes := currentRes ++ [ decodedDir_(code) ]
  }
  return (currentRes)
}

function substractOneFromDirCodes_(codes) {
  /* PRECOND: codes is not [] or [1] 
     OBS: substracts one in a 0-less representation in base 4
  */
  curCode  := head(codes)
  curCodes := tail(codes)
  curSeen := []
  while (curCode==1 && not isEmpty(curCodes)) {
        curSeen  := curSeen ++ [4]
        curCode  := head(curCodes)
        curCodes := tail(curCodes)
  }
  if (curCode>1) { curSeen := curSeen++[curCode-1] }
  return (curSeen++curCodes)
}

// ---------
// Pairs
// ---------
function fst(pair) {
    return(matching (pair) select 
               x on (x,y)
               boom(msgNotExpected("pair (A,B)")) otherwise)
}

function snd(pair) {
    return(matching (pair) select 
               y on (x,y)
               boom(msgNotExpected("pair (A,B)")) otherwise)
}

// ---------
// Maybe 
// ---------
type Maybe is variant {
  case Nothing  {}
  case Just     { field fromJust }  
}

function isNothing(mv) {
  return(matching (mv) select
           True on Nothing
           False otherwise)
}

function just(elem) {
  return (Just(fromJust <- elem))
}

function firstOf_Or_(md1, md2) {
 return(matching (md1) select
          md1 on Just
          md2 otherwise)
}


procedure DrawMNum_With_(mNum, color) {
  Drop__Times(color
            , matching (mNum) select
                1 + fromJust(mNum) on Just
                0                  otherwise
  )
}

function currentMNumWith_(color) {
  return (choose
            Nothing                   when (numStones(color) == 0)
            just(numStones(color)-1)  otherwise)
}

procedure DrawMDir_With_(mdir, color) {
  Drop__Times(color, codeOfMDir_(mdir))
}

function codeOfMDir_(mdir) {
  return (matching (mdir) select codeOfDir_(fromJust(mdir)) on Just
                                 5                          otherwise)
}

function currentMDirWith_(color) {
  /* PRECOND:
       * there is a MDir represented (between 1 to 5 color stones)
  */
  return(choose Nothing                      when (numStones(color)==5)
                just(currentDirWith_(color)) otherwise)
}

// ---------
// Pos
// ---------
type Pos is record {
   field row    // Number
   field col    // Number
}

function pos(c, r) { return(Pos(row <- r, col <- c)) }

procedure GoToCell_(pos) {
  GoToEdge(West)      
  Move__Times(East, col(pos))   
  GoToEdge(South)  
  Move__Times(North, row(pos))    
}

function currentPos() {
  return(Pos(row <- rowIndex()
            ,col <- colIndex()))
}

function rowIndex() { return(distanceToEdge_(South)) }
function colIndex() { return(distanceToEdge_(West))  }

function distanceToEdge_(dir) {
  measured := 0
  while (canMove(dir)) { Move(dir); measured := measured+1 }
  return (measured)
}

function nextPosOf_To_(pos,dir) {
  return (Pos(row <- row(pos) + vOffset(dir)
             ,col <- col(pos) + hOffset(dir)
  ))
}

function vOffset (dir) {
  return (matching (dir) select
            -1 on South
             1 on North
             0 otherwise) 
}

function hOffset (dir) {
  return (matching (dir) select
            -1 on West
             1 on East
             0 otherwise) 
}

procedure DrawPos_With_(vec, color) {
  Drop__Times(color, codeOfPos_(vec))
}

function codeOfPos_(vec) {
  /* PRECOND: * col of vec <= 999 */
  return (row(vec)*1000 + col(vec))
}

function currentPosWith_(color) {
  code := numStones(color)
  return (Pos(row <- code div 1000
             ,col <- code mod 1000
  ))
}

// ---------
// Genders 
// ---------
type Gender is variant {
   case Masculine {}
   case Femenine {}
   // case Both {}
   // case None {}
}

procedure DrawGender_With_(gender, color) {
   Drop__Times(color, codeOfGender_(gender))
}

function codeOfGender_(gender) {
  return (matching (gender) select
            1 on Masculine
            2 on Femenine
            boom(msgNotExpected("Gender")) otherwise)
}

function currentGenderWith_(color) {
  /* PRECOND:
       * there is a gender represented (between 1 to 2 color stones)
  */
  return(decodeGender_(numStones(color)))
}

function decodeGender_(code) {
  /* PRECOND:
       * code is the coding of a Gender (between 1 and 2)
  */
  return(matching (code) select
           Masculine  on 1
           Femenine   on 2
           boom(msgNotACodeFor_("Gender")) otherwise)
}

// ---------
// Board traversal operations 
// ---------
procedure StartBoardTraverseTo_And_(mainDir, secDir) {
  GoToCorner__(opposite(mainDir), opposite(secDir))
}

function atEndOfBoardTraverseTo_And_(mainDir, secDir) {
  return(not canMove(mainDir) && not canMove(secDir))
}

procedure GoToNextCellInBoardTraverseTo_And_(mainDir, secDir) {
  /* PRECOND:
     * head is not at end of a board traverse to mainDir and secDir
  */
  if (canMove(mainDir)) { Move(mainDir) }
  else                  { GoToEdge(opposite(mainDir))
                          Move(secDir)
                        }
}

// ---------
// List functions 
// ---------
function elemAtPos_In_(pos,xss) {
  /* PRECOND:
       * there are at least 1+row(pos) elements in xss
       * there are at least 1+col(pos) elements in elemAtIndex_In_(row(pos),xss)
  */
  row := elemAtIndex_In_(row(pos), xss)
  return(elemAtIndex_In_(col(pos), row))
}

function elemAtIndex_In_(idx,xs) { 
  /* PRECOND: * there are at least 1+idx elements in xs */
  return(list_At_(xs,idx)) 
}

function lengthOf_(xs) {
  counted := 0
  foreach elem in xs { counted := counted+1 }
  return (counted)
}

function list_At_(xs, idx) {
  /* PRECOND: * there are at least 1+idx elements in xs */
  currentList := xs
  repeat (idx) { currentList := tail(currentList) }
  return (head(currentList))
}

function column_Of_(col, xss) {
  /* PRECOND:
       * all elements.of xss have at least col+1 elements
  */
  columnSeen := [ ]
  foreach row in xss { columnSeen := columnSeen ++ [ elemAtIndex_In_(col, row) ] }
  return (columnSeen)
}

function set_AtPos_To_(xss, pos, x) {
  row    := list_At_(xss, row(pos))
  newRow := set_AtIndex_To_(row, col(pos), x)
  return(set_AtIndex_To_(xss, row(pos), newRow))
}

function set_AtIndex_To_(xs, i, x) {
  /* PRECOND:
       * xs has at least i+1 elements
  */
  let (prev, oldX, post) := split_At_(xs, i)
  return(prev ++ [x] ++ post)
}

function split_At_(xs, i) {
  /* PRECOND: 
       * xs has at least i+1 elements
  */
  seen := [ ]
  toSee := xs
  repeat (i) { 
     seen := seen ++ [ head(toSee) ]
     toSee := tail(toSee)
  }
  return(seen, head(toSee), tail(toSee))
}

function reverse(xs) {
  reversed := []
  foreach x in xs {
    reversed := [x]++reversed
  }
  return(reversed)
}

function replicate__Times(x, n) {
  processed := []
  repeat(n) { processed := [x] ++ processed }
  return (processed)
}

function listFrom_To_(low,high) {
  processed := []
  current := low
  repeat (high - low + 1) {
    processed := [current] ++ processed
    current := current + 1
  }
  return (processed)
}

// ---------
// Stacks 
// ---------
type Stack is record {
  field data  // [ Elements ]
}

function emptyS()     { return (Stack(data <- [ ]))             }
function isEmptyS(st) { return(not isEmpty(data(st)))           }
function push(x, st)  { return (Stack(data <- [x] ++ data(st))) }
function top(st)      { return (head(data(st)))                 } /* PRECOND: st is not empty */
function pop(st)      { return (Stack(data <- tail(data(st))))  } /* PRECOND: st is not empty */

// ---------
// ERROR MESSAGES
// ---------
function msgNotACodeFor_(element) {
  return(babel("Not a code"
              ,"No es un código")) 
}
/* ============================================================================================================
   END Prelude.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-IO.gbs
   Operations to draw and read a Quell level from the board
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
   ============================================================================================================
   TO-DO: Add a top bar to the board representation (in order to add the solution, the numMoves, and represent spikesDir in a better way)
*/

// ---------
// Quell I/O operations
// ---------
function currentQuell() {
  /* PRECOND: * there is a quell level represented in the Gobstones board */
  return (currentQLevel())
}

procedure WriteQuell_(quell) {
  /* PRECOND: * Gobstones board is big enough to represent the quell board */
  DrawQLevel_(quell)
}

// ---------
// Representation
// ---------
/*
  The ball is represented with ballColor() stones (standard representation for MDir:, 1 to 5 stones:
    + moving North, 1 or 6 stones
    + moving East,  2 or 7 stones
    + moving South, 3 or 8 stones
    + moving West,  4 or 9 stones
    + not moving,   5 stones)
     
   QElements are represented with qelemColor() stones, and their attributes with attrAColor() and attrBColor() stones, depending of the case.
    + Empty, no qelem stones
    + Pearl,      1 stone
    + Wall,       2 stones
    + Box,        3 stones
    + Limit,      4 stones
                     * isCorner, attrA stones (1-4 for corners, 5-8 for angles)
                     * pointsTo, attrB stones 
    + Portal, 5 stones
                     * doorA,    attrA stones
                     * doorB,    attrB stones
    + Multispike, 6 stones
    + Spike,      7 stones
                     * rotable,  attrA stones 
    + Switch,     8 stones
    + Gate,       9 stones
                     * open,     attrA stones
    + Out,       10 stones (or 110 for special case)
  
  QLevel info is represented at top row with 10x qelem stones (x the col Number) -- TO BE DONE
    * cell  0 at column 0 encode spikesDir in attrA stones
    * cell  1 at column 1 encode numMoves in attrA stones (100 for overload)
    * cell  2 at column 2 encode minMoves in attrA stones (100 for overload)
    * cell  0 at column 3 encode jewel position in attrAStones
    * cells 3 (or 0 if not used) from column 4 to 3-from-East encode solution in attrA and attrB stones 
           ([Dir] is encoded as a 0-less number in base 4, represented in base 100 in low first pairs of digits in order AB)
    * cell  4 at column 2 from East encode if jewel was found in attrB stones
    * cell  5 at column 1 from East encode numPearls in attrA stones
    * cell  0 at East edge with no extra information

  The jewel is represented on its position if it was not found, using
    + hitsReceived, attrA stones
*/

// ---------
// Reading operations
// OBS: All operations has as PRECOND:
//        * there is a quell level represented in the Gobstones board 
// ---------
function currentQLevel() {
  let (curSpikesDir, curNumMoves, curMinMoves
      ,curJewelPos, curJewelFound, curSolution
      ,curNumPearls)                         := currentQInfo()
  let (curBoard, checkNumPearls)             := currentQBoard()
  let (curBallMPos, curBallMDir)             := currentQBallInfo()
  curJewelInfo                               := currentQJewel(curJewelFound, curJewelPos)
  Assert_OrFail_(curNumPearls==checkNumPearls, msgInvalidQuell())
  return (QuellLevel(board     <- curBoard
                   , spikesDir <- curSpikesDir
                   , jewel     <- curJewelInfo
                   , ball      <- curBallMPos
                   , inTransit <- curBallMDir
                   , numPearls <- curNumPearls
                   , solution  <- curSolution
                   , minMoves  <- curMinMoves
                   , numMoves  <- curNumMoves))
}

// Level 1
function currentQInfo() {
  GoToTopRow()
  Assert_OrFail_(isCellAtTopRow(), msgNoQuellLevel())
  curSpikesDir  := currentMDirWith_(attrAColor())  Move(East)
  curNumMoves   := currentNumWith_(attrAColor())   Move(East)
  curMinMoves   := currentNumWith_(attrAColor())   Move(East)
  curJewelPos   := currentPosWith_(attrAColor())   Move(East)
  curSolution   := currentDirsWith_And_(attrAColor(), attrBColor())
  GoToEdge(East)                                   Move(West)
  curNumPearls  := currentNumWith_(attrAColor())   Move(West)
  curJewelFound := currentBoolWith_(attrBColor())
  return (curSpikesDir, curNumMoves, just(curMinMoves), curJewelPos, curJewelFound, curSolution, curNumPearls)
}

function currentQBoard() {
  GoToCorner__(South,East)
  curBoard     := [ ]
  curNumPearls := 0
  while (not atTopRow()) {
    let (row, numPearls) := currentRowInfo()
    curBoard     := curBoard ++ [ row ]
    curNumPearls := curNumPearls + numPearls
    Move(North)
  } 
  return(curBoard, curNumPearls)
}

function currentQBallInfo() {
  GoToBall()
  NormalizeBallIfNeeded()
  return(choose (just(currentPos()), currentMDirWith_(ballColor())) when (hasBall())
                (Nothing           , Nothing)                       otherwise)
}

function currentQJewel(found, jpos) {
  /* PRECOND: * there is a jewel represented in the board */
  GoToCell_(jpos)
  return(QJewel(found        <- found
              , jpos         <- jpos
              , hitsReceived <- numStones(attrAColor())-1))
}

// Level 2
procedure GoToBall() {
  StartBoardTraverseTo_And_(East, North)
  while(not atEndOfBoardTraverseTo_And_(East, North) 
     && not hasBall()) {
    GoToNextCellInBoardTraverseTo_And_(East, North) 
  }
}

procedure NormalizeBallIfNeeded() {
  if (ballIndicatesDirectionVisually()) { RemoveBallVisualIndication() }
}

function currentRowInfo() {
  GoToEdge(West)
  qelem := currentQElem()
  curRow       := [ qelem ]
  curNumPearls := delta(isPearl_(qelem))
  while (canMove(East)) {
     Move(East)
     qelem := currentQElem()
     curRow       := curRow ++ [ qelem ]
     curNumPearls := curNumPearls + delta(isPearl_(qelem))
  }
  return (curRow, curNumPearls)
}

function currentQElem() {
  /* PRECOND: * there is a qelem represented in the current cell */
  
  return(matching (numStones(qelemColor())) select
          Empty                 on 0
          Pearl                 on 1
          Wall                  on 2
          currentBox()          on 3
          currentLimit()        on 4
          currentPortal()       on 5
          Multispike            on 6
          currentSpike()        on 7
          currentSwitch()       on 8
          currentGate()         on 9
          Out                   on 10
          boom(msgNoQElement()) otherwise)
}

function currentBox() {
  /* PRECOND: * there is a box represented in the current cell */
  return(Box(gender <- currentGenderWith_(attrAColor())))
}

function currentLimit() {
  /* PRECOND: * there is a limit represented in the current cell */
  return(Limit(corner   <- currentCornerWith_(attrAColor())
             , pointsTo <- currentMDirWith_(attrBColor())))
}

function currentPortal() {
  /* PRECOND: * there is a portal represented in the current cell */
  return(Portal(doorA <- currentPosWith_(attrAColor())
              , doorB <- currentPosWith_(attrBColor())))
}

function currentSpike() {
  /* PRECOND: * there is a spike represented in the current cell */
  return(Spike(notRotable <- currentMDirWith_(attrAColor())))
}

function currentSwitch() {
  /* PRECOND: * there is a switch represented in the current cell */
  return(Switch)
}

function currentGate() {
  /* PRECOND: * there is a gate represented in the current cell */
  return(Gate(open <- currentBoolWith_(attrAColor())))
}

function currentCornerWith_(color) { 
  code := numStones(color)
  if (num_IsBetween_And_(code, 1, 4)) 
    { d1 := decodedDir_(code) 
      d2 := nextDir(d1)   
  } elseif (num_IsBetween_And_(code, 5, 8)) 
    { d1 := decodedDir_(code-4)
      d2 := prevDir(d1)   
  } else { }                                      
  return(choose just((d1,d2)) when (num_IsBetween_And_(code, 1, 8))
                Nothing       otherwise)
}

function currentDirsWith_And_(colorA, colorB) {
  code := currentCodeInBase_With_And_(100, colorA, colorB)
  return(decodedDirs_(code))
}

function currentCodeInBase_With_And_(base, colorA, colorB) {
  currentColor := colorA
  currentCode  := 0
  currentPow   := 1
  while (hasStones(colorA)) {
    currentDigit := currentNumWith_(currentColor)
    currentCode  := currentCode + currentDigit * currentPow
    currentPow   := currentPow * base
    if (currentColor == colorA) { currentColor := colorB            } 
     else                       { currentColor := colorA Move(East) }
  }
  return(currentCode)
}

function hasBall()   { return(num_IsBetween_And_(numStones(ballColor()), 1, 9))     }
function hasQJewel() { return((hasWall() || hasEmpty()) && hasStones(attrAColor())) }
function hasWall()   { return(numStones(qelemColor())==2)                           }
function hasEmpty()  { return(numStones(qelemColor())==0)                           }

// ---------
// Tutorial operations
// ---------
procedure MarkAsTutorial() {
  ClearBoard()
  GoToCorner__(South, West)
  Drop(attrBColor())
}

function isTutorialLevel() {
  GoToCorner__(South, West)
  return(hasStones(attrBColor()))
}

procedure AddBallVisualIndicationOn_(quell) {
  if (hasQBall_(quell) && not hasMovingQBall_(quell) && not isEmpty(solution(quell)) ) {
    GoToCell_(ballPosOn_(quell))
    AddBallVisualIndicationTo_(head(solution(quell)))
  }
}

function  ballIndicatesDirectionVisually() { return(num_IsBetween_And_(numStones(ballColor()), 6, 9)) }
procedure RemoveBallVisualIndication() { 
  /* PRECOND: there is a ball with visual indication (there are between 6 and 9 stones) in the current cell */
  Grab__Times(ballColor(), numStones(ballColor())-5) 
}
procedure AddBallVisualIndicationTo_(dir) { 
  /* PRECOND: there is a ball that is not moving and without visual indication (there are 5 stones) in the current cell */
  Drop__Times(ballColor(), codeOfDir_(dir)) 
}

// ---------
// Drawing operations
// ---------
procedure DrawQLevel_(quell) {
  DrawQBoard_WithSpikesTo_(board(quell), spikesDir(quell))
  DrawQInfo_(quell)
  DrawQJewel_(jewel(quell))
  DrawQBall_To_(ball(quell), inTransit(quell))
}

// Level 1
procedure DrawQInfo_(quell) {
  GoToEdge(West)  EncodeTopMDir_At_(spikesDir(quell), 0)
  Move(East)      EncodeTopNum_At_(numMoves(quell),1)
  Move(East)      EncodeTopNum_At_(fromJust(minMoves(quell)),2)
  Move(East)      EncodeTopPos_At_(jpos(jewel(quell)), 0)
  Move(East)      EncodeTopDirs_At_(solution(quell), 3)
   
  GoToEdge(East)  MarkTopCell_(0)
  Move(West)      EncodeTopNum_At_(numPearls(quell),5)
  Move(West)      EncodeTopBool_At_(found(jewel(quell)), 4)  
  Move(West)      PadEmptyCellAs_(0)
}

procedure DrawQBoard_WithSpikesTo_(board, spikesDir) {
  /* PRECOND: * the board has at least one qelem */
  GoToCorner__(South, West)
  foreach row in board {
    DrawQRow_WithSpikesTo_(row, spikesDir)
    Move(North)
  }
}

procedure DrawQBall_To_(ball, mdir) {
   if (not isNothing(ball)) {
     pos := fromJust(ball)
     GoToCell_(pos)
     DrawBall_(mdir)
   }
}

procedure DrawQJewel_(jewel) {
  GoToCell_(jpos(jewel))
  Drop__Times(attrAColor(), 1+hitsReceived(jewel))
  DrawBool_With_(found(jewel), attrBColor())
}

// Level 2

// Top row
procedure MarkTopCell_(i) { Drop__Times(qelemColor(), 100+i) }
procedure EncodeTopBool_At_(b ,i) { MarkTopCell_(i)  DrawBool_With_(b , attrBColor()) }
procedure EncodeTopMDir_At_(md,i) { MarkTopCell_(i)  DrawMDir_With_(md, attrAColor()) }
procedure EncodeTopPos_At_(pos,i) { MarkTopCell_(i)  DrawPos_With_(pos, attrAColor()) }

procedure EncodeTopDirs_At_(dirs, i) {
   code := codeOfDirs_(dirs)
   DrawTopCode_InBase_With_And_As_(code, 100, attrAColor(), attrBColor(), i)
}

procedure EncodeTopMNum_At_(mn, i) { MarkTopCell_(i) DrawMNum_With_(mn, attrAColor()) }
procedure EncodeTopNum_At_(n, i)   {
  MarkTopCell_(i)
  if (n < 100) { DrawNum_With_(n, attrAColor())   } 
   else        { DrawNum_With_(100, attrAColor()) }
}

procedure PadEmptyCellAs_(i) {
   while(not isCellAtTopRow()) {
      MarkTopCell_(i) 
      Move(West)
   }
}

procedure DrawTopCode_InBase_With_And_As_(code, base, colorA, colorB, i) {
  currentColor := colorA
  currentCode  := code
  while (currentCode > 0) {
    currentDigit := currentCode mod base
    currentCode  := currentCode div base
    DrawNum_With_(currentDigit, currentColor)
    if (currentColor == colorA) { MarkTopCell_(i)  currentColor := colorB } 
     else                       { Move(East)       currentColor := colorA }
  }
}

procedure GoToTopRow() {
  GoToCorner__(South, West)
  while (canMove(North) && not atTopRow()) { Move(North) }
}

function atTopRow ()      { return(isCellAtTopRow())               }
function isCellAtTopRow() { return(numStones(qelemColor()) >= 100) }


// Ball
procedure DrawBall_(mdir) {
  DrawMDir_With_(mdir, ballColor())
}

// Board
procedure DrawQRow_WithSpikesTo_(row, spikesDir) {
  /* PRECOND: * the row has at least one element */
  GoToEdge(West)
  DrawQelem_WithSpikesTo_(head(row), spikesDir)
  foreach qelem in tail(row) {
    Move(East)
    DrawQelem_WithSpikesTo_(qelem, spikesDir)  
  }
}

procedure DrawQelem_WithSpikesTo_(qelem, spikesDir) {
  Drop__Times(qelemColor(), codeOfQelem_(qelem))
  switch (qelem) to {
    Box(gender)             -> { DrawGender_With_(gender   , attrAColor()) }
    Limit(corner, pointsTo) -> { DrawCorner_With_(corner   , attrAColor())
                                 DrawMDir_With_  (pointsTo , attrBColor()) }
    Portal(doorA, doorB)    -> { DrawPos_With_   (doorA    , attrAColor())
                                 DrawPos_With_   (doorB    , attrBColor()) }
    Spike(rotable)          -> { DrawMDir_With_  (rotable  , attrAColor()) }
    Switch()                -> { DrawMDir_With_  (spikesDir, attrAColor()) }
    Gate(open)              -> { DrawBool_With_  (open     , attrAColor()) }
    _                       -> { }
    }
}

procedure DrawCorner_With_(corner, color) {
  switch (corner) to {
    Nothing    -> { Drop__Times(color, 9) }
    Just(d1d2) -> { d1 := fst(d1d2)
                    d2 := snd(d1d2)
                    if     (d2==nextDir(d1)) { DrawDir_With_(d1,color)              }
                    elseif (d2==prevDir(d1)) { Drop__Times(color, 4+codeOfDir_(d1)) }
                    else                     { BOOM(msgInvalidQuell())              }
                  }
  }
}

// ---------
// Codes
// ---------
function codeOfQelem_(qelem) {
  return (matching (qelem) select
             0 on Empty
             1 on Pearl
             2 on Wall
             3 on Box
             4 on Limit
             5 on Portal
             6 on Multispike
             7 on Spike
             8 on Switch
             9 on Gate
            10 on Out
            boom(msgNotExpected("QElem")) otherwise
  )
}

// ---------
// Colors
// ---------
function ballColor()  { return(Blue)  }
function qelemColor() { return(Black) }
function attrAColor() { return(Red)   }
function attrBColor() { return(Green) }

// ---------
// Error messages
// ---------
function msgNoQuellLevel() { 
  return(babel("There is no Quell level represented on the board"
              ,"No hay un nivel de Quell representado en el tablero"))
}

function msgNoQElement() { 
  return(babel("There is no QElement represented in the current cell"
              ,"No hay un QElement representado en la celda actual"))
}

function msgInvalidQuell() { 
  return(babel("Quell representation is invalid"
              ,"La representación de Quell es inválida"))
}

/* ============================================================================================================
   END Quell-IO.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Model.gbs
   Definition of the datatypes representing a Quell level
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
   ============================================================================================================
*/

type QuellLevel is record {
  /* INV.REP.:
       * board represent a Quell level
           - all elements of the list at field board are lists of the same length
           - all rows or columns that have some element diferent of Out have at least 2 Limits pointing to each other (no other limit in between 2 pointing limits), and all elements different from Out in between a pair of pointing limits, and no Out elements are in between a pair of pointing limits
           - if the ball field is Just(fromJust<-pos), then the element at pos in board is either Empty or an open Gate or a Portal or a Switch, and pos is between Limits pointing to each other
           - the inTransit field is Just(dirOfMove) iff ball is not Nothing and the QElem in the next position in the dirOfBoard (see nextPos) is not a blocking element, that is:
               + a Wall, or 
               + a Spike pointing at opposite(dirOfMove), or 
               + a closed Gate
               + a blocked Box
           - all doors of Portals are valid positions in the board
           - every QElem equal to a Portal is placed at one of its doors' position, and in the other position there is also a Portal with matching doors
           - all Switches have the same value in their dir fields
           - all Spikes that have the  rotable field in True, have the same value for their dir field, and it is the same value than the dir field in all Switches
       * numPearls is equal to the number of pearls in the board
       * minMoves is the minimum number of moves required to solve the level using Quell rules (Nothing if not solvable)
       * the pos at field jewel indicates a valid position in the given board, and the QElem in that position is either Wall or Empty
       * the QElem at SouthWest corner of the board is Out (for drawing information about the level)
       * either there is any rotable spikes, at least a Switch, and spikeDir should be different from Nothing, 
             or there is no rotable spikes, no Switches, and spikeDir is Nothing
   */
   field board     // [[QElem]] 
   field spikesDir // Maybe(Direction)
   field jewel     // QJewel
   field ball      // Maybe(Pos)
   field inTransit // Maybe(Dir)
   field numPearls // Number
   field solution  // [Dir]
   field minMoves  // Maybe(Number)
   field numMoves  // Number
}

type QElem is variant {
   case Empty      {}
   case Pearl      {}
   case Wall       {}
   case Box        { field gender }     // Gender
   case Limit      { field corner       // Maybe((Dir, Dir))
                     field pointsTo     // Maybe(Dir)
                   }
   case Portal     { field doorA        // Pos
                     field doorB        // Pos
                   }
   case Multispike {}
   case Spike      { field notRotable } // Maybe(Dir)
   case Switch     { } 
   case Gate       { field open }       // Bool
   case Out        {}
}

type QJewel is record {
   field jpos         // Pos
   field hitsReceived // Number 
   field found        // Bool
}

type BallAction is variant {
  case Move {}
  case Stay {}
  case Pop  {}
}

// ---------------------------
//  Abbreviations
// ---------------------------
function cNW()     { return(Limit(corner   <- just((East , South)), pointsTo <- Nothing))   }
function cNE()     { return(Limit(corner   <- just((South, West )), pointsTo <- Nothing))   }
function cSE()     { return(Limit(corner   <- just((West , North)), pointsTo <- Nothing))   }
function cSW()     { return(Limit(corner   <- just((North, East )), pointsTo <- Nothing))   }

function cNW_(dir) { return(Limit(corner   <- just((East , South)), pointsTo <- just(dir))) }
function cNE_(dir) { return(Limit(corner   <- just((South, West )), pointsTo <- just(dir))) }
function cSE_(dir) { return(Limit(corner   <- just((West , North)), pointsTo <- just(dir))) }
function cSW_(dir) { return(Limit(corner   <- just((North, East )), pointsTo <- just(dir))) }

function aNW()     { return(Limit(corner   <- just((South, East )), pointsTo <- Nothing))   }
function aNE()     { return(Limit(corner   <- just((West , South)), pointsTo <- Nothing))   }
function aSE()     { return(Limit(corner   <- just((North, West )), pointsTo <- Nothing))   }
function aSW()     { return(Limit(corner   <- just((East , North)), pointsTo <- Nothing))   }

function aNW_(dir) { return(Limit(corner   <- just((South, East )), pointsTo <- just(dir))) }
function aNE_(dir) { return(Limit(corner   <- just((West , South)), pointsTo <- just(dir))) }
function aSE_(dir) { return(Limit(corner   <- just((North, West )), pointsTo <- just(dir))) }
function aSW_(dir) { return(Limit(corner   <- just((East , North)), pointsTo <- just(dir))) }

function lH_(dir)  { return(Limit(corner   <- Nothing    , pointsTo <- just(dir))) }
function lV_(dir)  { return(Limit(corner   <- Nothing    , pointsTo <- just(dir))) }

// ---------------------------
//  Detection functions
// ---------------------------
function isEmpty_(qelem)      { return(matching (qelem) select True  on Empty       False otherwise) }
function isPearl_(qelem)      { return(matching (qelem) select True  on Pearl       False otherwise) }
function isWall_(qelem)       { return(matching (qelem) select True  on Wall        False otherwise) }
function isBox_(qelem)        { return(matching (qelem) select True  on Box         False otherwise) }
function isLimit_(qelem)      { return(matching (qelem) select True  on Limit       False otherwise) }
function isPortal_(qelem)     { return(matching (qelem) select True  on Portal      False otherwise) }
function isMultispike_(qelem) { return(matching (qelem) select True  on Multispike  False otherwise) }
function isSpike_(qelem)      { return(matching (qelem) select True  on Spike       False otherwise) }
function isSwitch_(qelem)     { return(matching (qelem) select True  on Switch      False otherwise) }
function isGate_(qelem)       { return(matching (qelem) select True  on Gate        False otherwise) }
function isOut_(qelem)        { return(matching (qelem) select True  on Out         False otherwise) }

function isRotableSpike(qelem) {
  return(matching (qelem) select 
           isRotable_(qelem) on Spike
           False             otherwise)
}

function isRotable_(qelem) {
  /* PRECOND: qelem is a Spike */
   return(notRotable(qelem)==Nothing)
}

// ---------------------------
//  Ball information
// ---------------------------
function dirOfBallOn_(quell)    { return(inTransit(quell))                           }
function hasQBall_(quell)       { return(not isNothing(ball(quell)))                 }
function hasMovingQBall_(quell) { return(hasQBall_(quell) && ballOn_IsMoving(quell)) }
function ballOn_IsMoving(quell) { return(not isNothing (inTransit(quell)))           }

function ballPosOn_(quell) {
  /* PRECOND: * there is a Ball in quell (ball(quell) is not Nothing) */
  return (fromJust(ball(quell)))
}
/* ============================================================================================================
   END Quell-Model.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Operations.gbs
   Operations to perform a step of movement (with all the needed changes)

   This version follows REPL style (Read-Eval-Print-Loop). 
   The board is used only to show the information, and to store the state of the game between loops. 
   All the game operations are performed on the model (which has some problems that needs fixing if this style is to be used).
   However, this approach shown inefficient, and for that reason we will explore other styles, where the board
   is used for processing.
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
// REQUIRE: Quell-IO.gbs
   ============================================================================================================
*/
procedure ProcessMoveTo_(dir) { AuxProcessMoveTo_(just(dir)) }
procedure ProcessMove()       { AuxProcessMoveTo_(Nothing)   }

procedure AuxProcessMoveTo_(mdir) {
  quell      := currentQuell()
  isTutorial := isTutorialLevel()
  newQuell   := quell_WithOneStepTo_(quell, mdir)
  MarkAsTutorial()
  AddBallVisualIndicationOn_(newQuell)
  WriteQuell_(newQuell)
//  AnalizeEndingOn_(newQuell)
}

// ---------
// Quell operative functions
// ---------
function quell_WithOneStepTo_(quell, mdir) {
  /* OBS: If the ball is moving, dir is ignored. If there is no ball, there is nothing to do. */
  newQuell := quell
  if (hasMovingQBall_(newQuell) || stepAt_StartsMoveTo_(newQuell, mdir)) {
    // Determine the direction of movement, and adjust solution if a movement starts
    if (hasMovingQBall_(newQuell)) 
      { dirOfMove := fromJust(dirOfBallOn_(newQuell)) }
    else
      { dirOfMove := fromJust(mdir)
        newQuell  := quell_WithAdjustedSolutionFor_(newQuell, dirOfMove)
      }

    let (curPos, curQE)   := currentDataOn_(newQuell)      
    let (nextPos, nextQE) := nextDataOn_From_To_(newQuell, curPos, dirOfMove)

   // COMPLETAR     
   //    If nextQE is a box, calculate its immediate next      
   // Mejorar el análisis de adjusted
   // let (dirOfMove, nextQE, nextPos) :=  adjusted_And_In_WRT_In_On_(dirOfMove, nextQE, nextPos, curQE, curPos, newQuell)
    
    action       := whatHappensIn_MovingTo_On_(nextQE, dirOfMove, newQuell)
    globalAction := globalActionFrom_On_(nextQE, newQuell)
    newQuell     := afterAction_On_With_At_And_At_To_(action, newQuell, curQE, curPos, nextQE, nextPos, dirOfMove)
    newQuell     := afterGlobal_On_(globalAction, newQuell)
  }
  return(newQuell)
}

function quell_WithAdjustedSolutionFor_(quell, dirOfMove) {
  /* PRECOND: there is a ball */
   newSolution := solution(quell)
   if (not isEmpty(newSolution) && head(newSolution) == dirOfMove)
        { newSolution := tail(newSolution) }
   else { newSolution := []                }
   return(QuellLevel(quell | solution <- newSolution, numMoves <- numMoves(quell) + 1))
}

// ---------
// Topological determination of data
// ---------
function currentDataOn_(quell) {
  pos := ballPosOn_(quell)
  return(pos, elemAtPos_In_(pos, board(quell)))
}

function nextDataOn_From_To_(quell, pos, dir) {
  /* PURPOSE: calculates the next position and element for balls AND boxes */
  let (nextPos, nextQE) := neighborDataOn_From_To_(quell, pos, dir)

  // The next of a limit is the next of the matching limit. This control has to be first, in case that next is a Portal
  if (isLimit_(nextQE)) {
    newPos  := matchingLimitFor_At_To_In_(nextQE, nextPos, dir, board(quell))
    nextPos := nextPosOf_To_(newPos, dir)      
    nextQE  := elemAtPos_In_(nextPos, board(quell))
  }

  // Entering a portal always ends in the target
  if (isPortal_(nextQE)) {
    nextPos := targetOf_From_(nextQE, nextPos)
    nextQE  := elemAtPos_In_(nextPos, board(quell))
  }

  return (nextPos, nextQE)
}

function neighborDataOn_From_To_(quell, pos, dir) {
  neighPos := nextPosOf_To_(pos, dir)
  return(neighPos, elemAtPos_In_(neighPos, board(quell)))
}

// ---------
// Other
// ---------
function adjusted_And_In_WRT_In_On_(dir, next, nextPos, current, curPos, quell) {
  /* OBS: the 3 checks are sequential to allow complex configurations (i.e. a portal besides another portal with a Limit besides its target) */
  curDir      := dir
  curlNextPos := nextPos
  curlNext    := next
  
  if (isPortal_(current) && isBlocking_(curNext) && not isDangerous_From_On_(curNext, curDir, quell)) {
    curDir     := opposite (curDir)
    newPos     := targetOf_From_(current, curPos)
    curNextPos := nextPosOf_To_(newPos, curDir)
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  }
  
  if (isPortal_(curNext)) {
    curNextPos := targetOf_From_(curNext, curNextPos)
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  } 

  if (isLimit_(curNext)) {
    newPos     := matchingLimitFor_At_To_In_(curNext, curNextPos, curDir, board(quell))
    curNextPos := nextPosOf_To_(newPos, curDir)      
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  }
  
  return (curDir, curNext, curNextPos)
}

function whatHappensIn_MovingTo_On_(qelem, dir, quell) {
  return (choose Pop  when (isDangerous_From_On_(qelem, dir, quell))
                 Stay when (isBlocking_(qelem))
                 Move otherwise
  )
}

function globalActionFrom_On_(qelem, quell) {
  return (matching (qelem) select
            spikesDir(quell) on Switch
            Nothing          otherwise)
}

function afterAction_On_With_At_And_At_To_(action, quell, current, curPos, next, nextPos, dir) {
    switch (action) {
       Pop  -> { newQuell := QuellLevel(quell | inTransit <- Nothing, ball <- Nothing) }
       Stay -> { newQuell := QuellLevel(quell | inTransit <- Nothing)
                 newQuell := withAdjustedJewelAt_On_(nextPos, newQuell)
               }
       Move -> { newQuell := QuellLevel(quell| inTransit <- just(dir), ball <- just(nextPos))
                 newQuell := withNew_At_And_At_To_On_(current, curPos, next, nextPos, dir, newQuell)
                 newQuell := withAdjustedJewelAt_On_(nextPos, newQuell)
               }
     }
    return (newQuell)
}

function afterGlobal_On_(gaction, quell) {
    return (matching (gaction) select
              QuellLevel(quell | spikesDir <- fromJust(gaction)) on Just
              quell                                              otherwise)
}

function withNew_At_And_At_To_On_(current, curPos, next, nextPos, dir, quell) {
   newCurrent := elem_AfterLeaving(current)
   newNext    := elem_AfterEnterFrom_(next, dir)
   newBoard   := set_AtPos_To_(set_AtPos_To_(board(quell)
                                           , curPos, newCurrent)
                             , nextPos, newNext)
   return (QuellLevel(quell | board     <- newBoard
                            , numPearls <- adjustPearls(numPearls(quell), next))
      )
 }

function withAdjustedJewelAt_On_(pos, quell) {
  jewel    := jewel(quell)
  hits     := hitsReceived(jewel)
  newJewel := QJewel(jewel | hitsReceived <- (1+hits) mod 3
                          , found <- hits==2)
  return (choose QuellLevel (quell | jewel <- newJewel)  when (not found(jewel) && pos==jpos(jewel))
                 quell                                   otherwise)
}
           
function elem_AfterEnterFrom_(qelem, dir) {
  return (matching (qelem) select
            Empty on Pearl
            qelem otherwise)
}

function elem_AfterLeaving(qelem) {
  return (matching (qelem) select
            Gate(open <- False) on Gate
            qelem               otherwise
  )
}

function adjustPearls (num, qelem) {
  return(matching (qelem) select
           num-1 on Pearl
           num otherwise)
}

// ---------
// Basic Quell functions
// ---------
function stepAt_StartsMoveTo_(quell, mdir) { return (hasQBall_(quell) && not ballOn_IsMoving(quell) && not isNothing(mdir)) }

function isDangerous_From_On_(qelem, dir, quell) {
  return(matching (qelem) select
           dirOfSpikesOf_At_(qelem, quell)==opposite(dir) on Spike
           True                                           on Multispike
           False                                          otherwise)
}

function dirOfSpikesOf_At_(qelem, quell) {
  /* PRECOND: qelem is a Spike */
  return(choose spikesDir(quell)             when (isRotable_(qelem))
                fromJust(notRotable(qelem)) otherwise)
}

function isBlocking_(qelem) {
  return(matching (qelem) select
           True            on Wall
           True            on Spike
           True            on Multispike
           not open(qelem) on Gate
           False           otherwise)
}

function targetOf_From_(qportal, pos) {
  /* PRECOND: * qportal is a Portal */
 return (choose doorA(qportal) when (doorB(qportal)==pos)
                doorB(qportal) when (doorA(qportal)==pos)
                pos            otherwise)
}

// ---------
// Functions for Limits
// ---------
function matchingLimitFor_At_To_In_(qelem, pos, dir, board) {
  /* PRECOND:
       * the qelem in board at pos is a Limit pointing to other limit
       * board is the board of a valid QLevel
  */
 return(choose
          Pos (row <- row(pos)
              ,col <- indexOfLimitNotAt_In_(col(pos), elemAtIndex_In_(row(pos), board)))    when (isHorizontal(dir)) 
          Pos (row <- indexOfLimitNotAt_In_(row(pos), column_Of_(col(pos)     , board))
              ,col <- col(pos))                                                             otherwise)
}

function indexOfLimitNotAt_In_(idx, qs) {
  /* PRECOND: * there are at least two Limits in qs pointing to each other, one of them at pos */
  let (before, qelem, after) := split_At_(qs, idx)
  Assert_OrFail_ (isLimit_(qelem), msgNotALimit())
  if (pointsBackwards_(qelem)) 
       { let (matchingIdx, matchingQE) := firstLimitBackwardsIn_(before)
         Assert_OrFail_(pointsForwards_(matchingQE), msgMalformedBoard())
       }
  elseif (pointsForwards_(qelem)) 
       { let (matchingIdx, matchingQE) := firstLimitForwardsIn_(after)
         Assert_OrFail_(pointsBackwards_(matchingQE), msgMalformedBoard())
         matchingIdx := matchingIdx + idx + 1
       }
  else { BOOM(msgNotABorder()) }
  return(matchingIdx)
}

function pointsBackwards_(qelem) {
  dir := pointsTo(qelem)
  return(dir == just(South) || dir == just(West))
}

function pointsForwards_(qelem) {
  dir := pointsTo(qelem)
  return(dir == just(North) || dir == just(East))
}

function firstLimitBackwardsIn_(qs) {
  /* PRECOND: qs has a Limit */
  let (idx, qelem) := firstLimitForwardsIn_(reverse(qs))
  return (idx+lengthOf_(qs)-1, qelem)
}

function firstLimitForwardsIn_(qs) {
  /* PRECOND: qs has a Limit */
   idx     := 0
   qelem   := head(qs)
   current := tail(qs)
   while(not isLimit_(qelem)) {
     idx     := idx + 1
     qelem   := head(current)
     current := tail(current)
   }
   return(idx, qelem)
}

// ---------
// Error messages
// ---------
function msgMalformedBoard() { return(babel("Malformed board", "Tablero mal formado"))          }
function msgNotALimit()      { return(babel("QElement at the given position is not a Limit"
                                          , "El QElement en la posición dada no es un Límite")) }
function msgNotABorder()     { return(babel("Limit at the given position is not a border"
                                          , "El Límite en la posición dada no es un borde"))    }
/* ============================================================================================================
   END Quell-Operations.gbs
   ============================================================================================================
*/
