/* ============================================================================================================
   START Babel.gbs
   Code for swap between  errors messages on different languages
   ============================================================================================================
*/
function language() { return(English) }

procedure Assert_OrFail_(condition, msg) { if (not condition) { BOOM(msg) } }
procedure ClearBoard()  { VaciarTablero() }

// ---------
// Internationalization
// ---------
type Language is variant {
  case English {}
  case Spanish {}
}

function babel(msgEn, msgSp) { 
  return(matching (language()) select 
           msgSp on Spanish
           msgEn otherwise)
}
/* ============================================================================================================
   END Babel.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START EnglishPrimitives.gbs
   Code for using English names on Gobstones programs, even when the language is still not internationalized
// REQUIRE: Babel.gbs
   ============================================================================================================
*/
// ---------
// Colors
// ---------
type Colour is variant {
    case Red    {}
    case Green  {}
    case Blue   {}
    case Black  {}
}

function colorEn2Sp(color) {
  return(matching (color) select
           Rojo   on Red
           Verde  on Green
           Azul   on Blue
           Negro  on Black
           boom(msgNotExpected("Colour")) otherwise)
}

function colorSp2En(color) {
  return(matching (color) select
           Red   on Rojo    
           Green on Verde   
           Blue  on Azul   
           Black on Negro
           boom(msgNotExpected("Color")) otherwise)
}

function hasStones(color) { return(hayBolitas(colorEn2Sp(color))) }
function numStones(color) { return(nroBolitas(colorEn2Sp(color))) }

procedure Drop(color) { Poner(colorEn2Sp(color)) }
procedure Grab(color) { 
    Assert_OrFail_(hasStones(color), msgNoStones())
    Sacar(colorEn2Sp(color)) 
}

function nextColor(color)  { return(colorSp2En(siguiente(colorEn2Sp(dir)))) }
function prevColor(color)  { return(colorSp2En(previo(colorEn2Sp(dir))))    }

function minColour() { return(colorSp2En(minColor())) }
function maxColour() { return(colorSp2En(maxColor())) }

// ---------
// Directions
// ---------
type Direction is variant {
    case North {}
    case East  {}
    case South {}
    case West  {}
}

function dirEn2Sp(dir) {
  return(matching (dir) select
           Norte on North
           Este  on East
           Sur   on South
           Oeste on West
           boom(msgNotExpected("Direction")) otherwise)
}

function dirSp2En(dir) {
  return(matching (dir) select
           North on Norte
           East  on Este 
           South on Sur  
           West  on Oeste
           boom(msgNotExpected("Dirección")) otherwise)
}

function canMove(dir) { return(puedeMover(dirEn2Sp(dir))) }

procedure Move(dir) { 
  Assert_OrFail_(canMove(dir), msgNoCells())
  Mover(dirEn2Sp(dir))     
}

procedure GoToEdge(dir) { IrAlBorde(dirEn2Sp(dir)) }

function opposite(dir) { return(dirSp2En(opuesto(dirEn2Sp(dir))))   }
function nextDir(dir)  { return(dirSp2En(siguiente(dirEn2Sp(dir)))) }
function prevDir(dir)  { return(dirSp2En(previo(dirEn2Sp(dir))))    }

function minDirection() { return(dirSp2En(minDir())) }
function maxDirection() { return(dirSp2En(maxDir())) }

// ---------
// Lists
// ---------
function isEmpty(xs) { return(esVacía(xs)) }
function head(xs)    { return(primero(xs)) }
function tail(xs)    { return(resto(xs))   }

// ---------
// ERROR MESSAGES
// ---------
function msgNoStones() { 
  return(babel("Cannot grab stones: there are no stones of that color"
              ,"No puedo sacar bolitas: no hay bolitas de ese color"
              ))
}

function msgNoCells() { 
  return(babel("Cannot move: there are no cells on that direction"
              ,"No puedo mover hacia ahí: no hay celdas en esa dirección"
              ))
}

function msgNotExpected(element) { 
  return(babel("CANNOT HAPPEN: has some element changed?"
              ,"NO PUEDE SUCEDER: ¿cambió algún elemento?"
              ))
}
/* ============================================================================================================
   END EnglishPrimitives.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Prelude.gbs
   General useful operations for a number of conveniencies
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
   ============================================================================================================
*/

// ---------
// Gobstones auxiliary functions
// ---------
procedure GoToCorner__(dir1, dir2) { /* PRECOND: dir1 and dir2 are not equal and not opposite of each other */                                            
  GoToEdge(dir1)
  GoToEdge(dir2)
}

procedure Drop__Times(color, num) { repeat (num) { Drop(color) } }
procedure Grab__Times(color, num) { repeat (num) { Grab(color) } }
procedure Move__Times(dir, num)   { repeat (num) { Move(dir)   } }

procedure GrabAll_(color) { Grab__Times(color, numStones(color)) }
procedure ClearCell() { foreach color in [minColour()..maxColour()] { GrabAll_(color) } }

function isHorizontal(dir) { return (dir==East  || dir==West)  }
function isVertical(dir)   { return (dir==North || dir==South) }

function adjust_To_(val, max)             { return ((val+max) mod max) }
function num_IsBetween_And_(n, low, high) { return(n>=low && n<=high)  }

function delta(b) { return (choose 1 when (b) 0 otherwise) }

// ---------
// Math functions 
// ---------
function truncate_ToMultipleOf_(n, b) { return (b * (n div b)) }

function timesOf_In_(p,n) { 
  currentN     := n
  currentTimes := 0
  while (currentN>=p) {
    currentTimes := currentTimes + 1
    currentN     := currentN-p
  }
  return (currentTimes)
}

function maxPowerOf_LessThan_(n, m) {
   currentPow := 1
   while (currentPow <= m) {
      currentPow := currentPow * n
   }
   return (currentPow div n)
}

function maxPowerOf_WithAccumPowLessThan_(n, p) {
   currentPow := 1
   currentSum := currentPow
   while (currentSum <= p) {
        currentPow := currentPow * n
        currentSum := currentPow + currentSum
    }
   return (currentPow div n)
}

// ---------
// Coding functions 
// ---------

// Dir
procedure DrawDir_With_(dir, color) { Drop__Times(color, codeOfDir_(dir))   }
function  currentDirWith_(color)    { return(decodedDir_(numStones(color))) } /* PRECOND: * there is a Dir represented (between 1 to 4 color stones) */

function codeOfDir_(dir) {
  return (matching (dir) select
            1 on North
            2 on East
            3 on South
            4 on West
            boom(msgNotExpected("Direction")) otherwise)
}

function decodedDir_(code) { /* PRECOND: code is the coding of a Dir (between 1 and 4) */
  return(matching (code) select
           North on 1
           East  on 2
           South on 3
           West  on 4
           boom(msgNotACodeFor_("Direction")) otherwise)
}

// Num
procedure DrawNum_With_(n, color) { Drop__Times(color, n)    }
function  currentNumWith_(color)  { return(numStones(color)) }

// Bool
procedure DrawBool_With_(b, color) { Drop__Times(color, codeOfBool_(b))     }
function  currentBoolWith_(color)  { return(decodedBool_(numStones(color))) } /* PRECOND: there is a bool represented in the current cell with the given color */

function codeOfBool_(b) {
  return (choose 1 when (b)
                 0 otherwise)
}

function decodedBool_(code) { /* PRECOND: code is the coding of a Bool (either 0 or 1) */
  return(matching (code) select
           True   on 1
           False  on 0
           boom(msgNotACodeFor_("Bool")) otherwise)
}

// [Dir]
function codeOfDirs_(dirs) {
  /* OBS: the coding is a 0-less one */
  currentCode := 0
  currentPow  := 1
  foreach dir in dirs {
    currentCode := currentCode + currentPow * codeOfDir_(dir)
    currentPow  := currentPow * 4
  }
  return (currentCode)
}
                
function decodedDirs_(code) {
   /* OBS: for decoding, 0-s need to be adjusted */
   curCodes   := []
   currentPow := maxPowerOf_WithAccumPowLessThan_(4, code)
   remCode    := code
   while (currentPow > 0) {                   // (code-remCode) is encoded in curCodes (shifted by currentPow)
     curCode    := timesOf_In_(currentPow, remCode)
     if (curCode == 0) {                      // As a code digit cannot be 0, 1 must be substracted of previous calculus
         curCodes := substractOneFromDirCodes_(curCodes)
         remCode  := remCode + currentPow * 4 // remCode needs adjustment too, to keep the invariant
         curCode  := 4
     }
     remCode    := remCode - (curCode * currentPow)
     currentPow := currentPow div 4
     curCodes      := [ curCode ] ++ curCodes
   }
   return(mapDecodeDirsTo_(curCodes))
}

function mapDecodeDirsTo_(codes) {
  currentRes := []
  foreach code in codes {
    currentRes := currentRes ++ [ decodedDir_(code) ]
  }
  return (currentRes)
}

function substractOneFromDirCodes_(codes) {
  /* PURPOSE: substracts one in a 0-less representation in base 4
     PRECOND: codes is not []  
  */
  curCode  := head(codes)
  curCodes := tail(codes)
  curSeen := []
  while (curCode==1 && not isEmpty(curCodes)) {
        curSeen  := curSeen ++ [4]
        curCode  := head(curCodes)
        curCodes := tail(curCodes)
  }
  if (curCode>1) { curSeen := curSeen++[curCode-1] }
  return (curSeen++curCodes)
}

// ---------
// Pairs
// ---------
function fst(pair) {
    return(matching (pair) select 
               x on (x,y)
               boom(msgNotExpected("pair (A,B)")) otherwise)
}

function snd(pair) {
    return(matching (pair) select 
               y on (x,y)
               boom(msgNotExpected("pair (A,B)")) otherwise)
}

// ---------
// Maybe 
// ---------
type Maybe is variant {
  case Nothing  {}
  case Just     { field fromJust }  
}

function isNothing(mv) { return(matching (mv) select True on Nothing False otherwise) }
function just(elem)    { return (Just(fromJust <- elem)) }

function firstOf_Or_(md1, md2) {
 return(matching (md1) select
          md1 on Just
          md2 otherwise)
}

procedure DrawMNum_With_(mNum, color) {
  Drop__Times(color, matching (mNum) select
                       1 + fromJust(mNum) on Just
                       0                  otherwise)
}

function currentMNumWith_(color) {
  return (choose
            Nothing                   when (numStones(color) == 0)
            just(numStones(color)-1)  otherwise)
}

procedure DrawMDir_With_(mdir, color) { Drop__Times(color, codeOfMDir_(mdir)) }
function codeOfMDir_(mdir) {
  return (matching (mdir) select codeOfDir_(fromJust(mdir)) on Just
                                 0                          otherwise)
}

function currentMDirWith_(color) { /* PRECOND: there is a MDir represented (between 1 to 5 color stones) */
  return(choose just(currentDirWith_(color)) when (hasStones(color))
                Nothing                      otherwise)
}

// ---------
// Pos
// ---------
type Pos is record {
   field row    // Number
   field col    // Number
}

function pos(c, r) { return(Pos(row <- r, col <- c)) }

procedure GoToCell_(pos) {
  GoToEdge(West)      
  Move__Times(East, col(pos))   
  GoToEdge(South)  
  Move__Times(North, row(pos))    
}

function currentPos() {
  return(Pos(row <- rowIndex()
            ,col <- colIndex()))
}

function rowIndex() { return(distanceToEdge_(South)) }
function colIndex() { return(distanceToEdge_(West))  }

function distanceToEdge_(dir) {
  measured := 0
  while (canMove(dir)) { Move(dir); measured := measured+1 }
  return (measured)
}

function nextPosOf_To_(pos,dir) {
  return (Pos(row <- row(pos) + vOffset(dir)
             ,col <- col(pos) + hOffset(dir)
  ))
}

function vOffset (dir) {
  return (matching (dir) select
            -1 on South
             1 on North
             0 otherwise) 
}

function hOffset (dir) {
  return (matching (dir) select
            -1 on West
             1 on East
             0 otherwise) 
}

procedure DrawPos_With_(vec, color) { Drop__Times(color, codeOfPos_(vec)) }

function currentPosWith_(color) {
  code := numStones(color)
  return (Pos(row <- code div 1000
             ,col <- code mod 1000
  ))
}

function codeOfPos_(vec) {
  /* PRECOND: col of vec <= 99 */
  return (row(vec)*100 + col(vec))
}

// ---------
// Genders 
// ---------
type Gender is variant {
   case Masculine {}
   case Femenine {}
   // case Both {}
   // case None {}
}

procedure DrawGender_With_(gender, color) { Drop__Times(color, codeOfGender_(gender)) }
function  currentGenderWith_(color)       { return(decodeGender_(numStones(color)))   } /* PRECOND: there is a gender represented (between 1 to 2 color stones) */

function codeOfGender_(gender) {
  return (matching (gender) select
            1 on Masculine
            2 on Femenine
            boom(msgNotExpected("Gender")) otherwise)
}

function decodeGender_(code) { /* PRECOND: code is the coding of a Gender (between 1 and 2) */
  return(matching (code) select
           Masculine  on 1
           Femenine   on 2
           boom(msgNotACodeFor_("Gender")) otherwise)
}

// ---------
// Board traversal operations 
// ---------
procedure StartBoardTraverseTo_And_(mainDir, secDir)   { GoToCorner__(opposite(mainDir), opposite(secDir))   }
function  atEndOfBoardTraverseTo_And_(mainDir, secDir) { return(not canMove(mainDir) && not canMove(secDir)) }
procedure GoToNextCellInBoardTraverseTo_And_(mainDir, secDir) { /* PRECOND: head is not at end of a board traverse to mainDir and secDir */
  if (canMove(mainDir)) { Move(mainDir) }
  else                  { GoToEdge(opposite(mainDir))
                          Move(secDir)
                        }
}

// ---------
// List functions 
// ---------
function lengthOf_(xs) {
  counted := 0
  foreach elem in xs { counted := counted+1 }
  return (counted)
}

function elem_IsIn_(x, xs) {
  current := xs
  while (not isEmpty(current) && x/=head(current)) {
    current := tail(current)
  }
  return (not isEmpty(current))
}

function elemAtPos_In_(pos,xss) {
  /* PRECOND:
       * there are at least 1+row(pos) elements in xss
       * there are at least 1+col(pos) elements in elemAtIndex_In_(row(pos),xss)
  */
  row := elemAtIndex_In_(row(pos), xss)
  return(elemAtIndex_In_(col(pos), row))
}

function elemAtIndex_In_(idx,xs) { return(list_At_(xs,idx)) } /* PRECOND: there are at least 1+idx elements in xs */

function list_At_(xs, idx) { /* PRECOND: there are at least 1+idx elements in xs */
  currentList := xs
  repeat (idx) { currentList := tail(currentList) }
  return (head(currentList))
}

function column_Of_(col, xss) { /* PRECOND: all elements of xss have at least col+1 elements */
  columnSeen := [ ]
  foreach row in xss { columnSeen := columnSeen ++ [ elemAtIndex_In_(col, row) ] }
  return (columnSeen)
}

function set_AtPos_To_(xss, pos, x) { /* PRECOND: xss has an element at pos */
  row    := list_At_(xss, row(pos))
  newRow := set_AtIndex_To_(row, col(pos), x)
  return(set_AtIndex_To_(xss, row(pos), newRow))
}

function set_AtIndex_To_(xs, i, x) { /* PRECOND: xs has at least i+1 elements */
  let (prev, oldX, post) := split_At_(xs, i)
  return(prev ++ [x] ++ post)
}

function split_At_(xs, i) { /* PRECOND: xs has at least i+1 elements */
  seen  := [ ]
  toSee := xs
  repeat (i) { 
     seen  := seen ++ [ head(toSee) ]
     toSee := tail(toSee)
  }
  return(seen, head(toSee), tail(toSee))
}

function reverse(xs) {
  reversed := []
  foreach x in xs {
    reversed := [x]++reversed
  }
  return(reversed)
}

function replicate__Times(x, n) {
  processed := []
  repeat(n) { processed := [x] ++ processed }
  return (processed)
}

function listFrom_To_(low,high) {
  processed := []
  current   := low
  repeat (high - low + 1) {
    processed := [current] ++ processed
    current   := current + 1
  }
  return (processed)
}

// ---------
// Stacks 
// ---------
type Stack is record {
  field data  // [ Elements ]
}

function emptyS()     { return(Stack(data <- [ ]))             }
function isEmptyS(st) { return(not isEmpty(data(st)))          }
function push(x, st)  { return(Stack(data <- [x] ++ data(st))) }
function top(st)      { return(head(data(st)))                 } /* PRECOND: st is not empty */
function pop(st)      { return(Stack(data <- tail(data(st))))  } /* PRECOND: st is not empty */

// ---------
// ERROR MESSAGES
// ---------
function msgNotACodeFor_(element) {
  return(babel("Not a code"
              ,"No es un código")) 
}
/* ============================================================================================================
   END Prelude.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Drawing.gbs
   Operations to draw a Quell level on the board. Awareness of Quell-Representation is needed
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
// REQUIRE: Quell-Representation.gbs
   ============================================================================================================
*/

procedure DrawQLevel_(quell) {
  /* OBS: to be used only on the initial drawing */
  ClearBoard()
  DrawTopBar_(quell)
  DrawQBoard_WithSpikesTo_(board(quell), spikesDir(quell))
  DrawQJewel_(jewel(quell))
  DrawQBoxes_(boxes(quell))
  DrawQBall_WithHintMDir_(ball(quell), firstTutorialDHintOn_(quell)) // The first time is accesed directly, without arithmetic operations
}

// ---------
// Drawing operations
// Level 1
// ---------
procedure DrawTopBar_(quell) {
  GoToCorner__(North,West); MarkTopCell_(0)
  Move(East)              ; EncodeTopNum_As_        (numMoves(quell)                  , 1)
  Move(East)              ; EncodeTopNum_As_        (minMoves(quell)                  , 2)
  GoToEdge(East)          ; EncodeTopMDir_As_       (spikesDir(quell)                 , 0)
  Move(West)              ; EncodeTopNum_AndMNum_As_(numPearls(quell), nHintOn_(quell), 4)
  Move(West)              ; EncodeTopJewel_As_      (jewel(quell)                     , 3)  
  Move(West)              ; PadEmptyCellAs_(0)
}

procedure DrawQBoard_WithSpikesTo_(board, spikesDir) { 
  /* PRECOND: the board has at least one qelem */
  GoToCorner__(North, West) Move(South)
  DrawQRow_WithSpikesTo_(head(board), spikesDir)
  foreach row in tail(board) { Move(South); DrawQRow_WithSpikesTo_(row, spikesDir) }
}

procedure DrawQJewel_(jewel) { if (isJewel_(jewel)) { GoToCell_(jpos(jewel)); DrawNum_With_(hits(jewel), attrAColor()) } }
procedure DrawQBoxes_(boxes) { 
  foreach box in boxes { 
    GoToCell_(fst(box))
    DrawBox_(snd(box))
  }
}

procedure DrawMovingQBall_(ball) { 
  /* PURPOSE: draw the ball in the current cell (ignoring bpos)
     PRECOND: isMovingBall_(ball) 
  */
  DrawDir_With_(goingTo(ball), ballColor())
  if (beaming(ball)) { Drop__Times(ballColor(), 10) }
}

procedure DrawStaticQBall_(ball) { 
  /* PURPOSE: draw the ball in the current cell (ignoring bpos)
     PRECOND: isStaticBall_(ball) 
  */
  Drop__Times(ballColor(), 5)
}

procedure DrawQBall_(ball)   { 
  /* PURPOSE: draw the ball in the current cell (ignoring bpos) */
  switch (ball) to {
    QBallAt(pos)               -> { DrawStaticQBall_(ball) }
    QBallTo(pos, dir, beaming) -> { DrawMovingQBall_(ball) }
    NoBall                     -> { }
  }
}  

procedure DrawQBall_WithHintMDir_(ball, mdir)   { 
  switch (ball) to {
    QBallAt(pos)               -> { GoToCell_(pos); DrawStaticQBall_(ball)
                                    DrawMDir_With_(mdir, ballColor())      }
    QBallTo(pos, dir, beaming) -> { GoToCell_(pos); DrawMovingQBall_(ball) }
    NoBall                     -> { }
  }
}

// ---------
// Drawing operations
// Level 2
// ---------
// Top bar operations
procedure MarkTopCell_(i)    { Drop__Times(qelemColor(), 100+i)                            }
procedure PadEmptyCellAs_(i) { while(not isCellAtTopRow()) { MarkTopCell_(i); Move(West) } }
function  isCellAtTopRow()   { return(numStones(qelemColor()) >= 100)                      }

procedure EncodeTopJewel_As_(jewel, i) {
  MarkTopCell_(i)
  DrawBool_With_(False, attrBColor()) // At the beginning the Jewel is not found
}

procedure EncodeTopBool_As_(b , i) { MarkTopCell_(i); DrawBool_With_(b , attrBColor()) }
procedure EncodeTopPos_As_(pos, i) { MarkTopCell_(i); DrawPos_With_(pos, attrAColor()) }
procedure EncodeTopMDir_As_(md, i) { MarkTopCell_(i); DrawMDir_With_(md, attrAColor()) }
procedure EncodeTopNum_As_(n  , i) { MarkTopCell_(i); DrawNum_With_(n  , attrAColor()) }
procedure EncodeTopNum_AndMNum_As_(n, mn, i) { 
  MarkTopCell_(i) 
  DrawNum_With_ (n, attrAColor()) 
  DrawMNum_With_(mn, attrBColor()) 
}

// Board
procedure DrawQRow_WithSpikesTo_(row, spikesDir) {
  /* PRECOND: the row has at least one element */
  GoToEdge(West)
  DrawQElem_WithSpikesTo_(head(row), spikesDir)
  foreach qelem in tail(row) { Move(East); DrawQElem_WithSpikesTo_(qelem, spikesDir) }
}

procedure DrawQElemId_(qelem) { Drop__Times(qelemColor(), codeOfQelem_(qelem)) }
procedure DrawQElem_WithSpikesTo_(qelem, spikesDir) {
  DrawQElemId_(qelem)
  switch (qelem) to {
    Pearl              -> { DrawBool_With_(True               , attrBColor())            }
    Corner(dir)        -> { DrawDir_With_ (dir                , attrAColor())            }
    Angle(dir)         -> { DrawDir_With_ (dir                , attrAColor())            }
    Limit(pointsTo)    -> { DrawDir_With_ (pointsTo           , attrAColor())            }
    Portal(id, target) -> { DrawPos_With_ (target             , attrAColor())            
                            DrawNum_With_ (id                 , attrBColor())            }
    Gate(closed)       -> { DrawBool_With_(closed             , attrBColor()) }
    Spike(dir)         -> { DrawDir_With_(dir                 , attrAColor())            }
    RotableSpike       -> { Assert_OrFail_(not isNothing(spikesDir), msgInvalidQuell()) // spikesDir cannot be Nothing if there are RotableSpikes
                            DrawDir_With_(fromJust(spikesDir) , attrAColor())            } 
    Switch             -> { Assert_OrFail_(not isNothing(spikesDir), msgInvalidQuell()) // spikesDir cannot be Nothing if there are Switches
                            DrawDir_With_(fromJust(spikesDir) , attrAColor())            } 
    _                  -> { }
    }
}

procedure DrawBox_(gender) {
  code := codeOfGender_(gender)
  DrawNum_With_(10*gender, attrBColor())
}

procedure DrawBeamingBox_(gender) {
  code := codeOfGender_(gender)
  DrawNum_With_(10*gender+10, attrBColor()) // Beaming is indicated with 10 more stones
}

// ---------
// Clearing operations
// ---------
procedure ClearBox() {
  /* PRECOND: there is a Box represented in the current cell */
  boxCode := truncate_ToMultipleOf_(currentNumWith_(attrBColor()), 10)
  Grab__Times(attrBColor(), boxCode)
}

procedure ClearAttrA()        { GrabAll_(attrAColor()) }
  
procedure ClearBall()         { GrabAll_(ballColor())  }
procedure ClearPearl()        { GrabAll_(attrBColor()) }
procedure ClearJewel()        { GrabAll_(attrBColor()) }
  
procedure ClearTopNumPearls() { GrabAll_(attrAColor()) }
procedure ClearTopNumMoves()  { GrabAll_(attrAColor()) }
procedure ClearTopHint()      { GrabAll_(attrBColor()) }
procedure ClearTopSpikesDir() { GrabAll_(attrAColor()) }

// ---------
// Error messages
// ---------
function msgInvalidQuell() { 
  return(babel("Quell representation is invalid"
              ,"La representación de Quell es inválida"))
}

/* ============================================================================================================
   END Quell-Drawing.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Logic.gbs
   Operations to perform a step of movement (with all the needed changes)
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
// REQUIRE: Quell-Representation.gbs
// REQUIRE: Quell-Drawing.gbs
// REQUIRE: Quell-Reading.gbs
   ============================================================================================================
*/

procedure ProcessStepTo_(mdir) {
  /* OBS: not all steps move. If there is no ball, or the ball is not moving and no key was pressed, 
          (that is, no movement occurs) nothing happens  
  */
  ball := currentQBall()
  if (movementOccursWith_And_(ball,mdir)) {
      ProcessMoveOf_To_(ball,mdir)
      // AnalizeEnding()
  }
}

// ---------
// Quell logic operations
// Level 1
// ---------
function movementOccursWith_And_(ball, mdir) { return(isBall_(ball) && (isMovingBall_(ball) || not isNothing(mdir))) }

procedure ProcessMoveOf_To_(theBall,mdir) {
  /* PRECOND: 
      * movementOccursWith_(ball)And_(mdir), that is, ball is different from NoBall, and if it is not moving, mdir is not Nothing
      * the current cell has the ball.
     OBS: * There are 3 kinds of moves: 
            + one that continues one already started, and
            + two that starts this turn (depending on the next valid QElement): 
                - one of them counts, and 
                - the other one is stopped immediately 
          * It is made in a highly imperative style for efficiency    
  */ 
  ball          := theBall
  dirOfMove     := dirOfMoveDeterminedBy_And_(ball, mdir)
  moveContinues := isMovingBall_(ball)
  if (not moveContinues) { ball := movedBall_To_(ball, dirOfMove) }
  
  curQE                         := currentQElem ()
  let (nextQE, nextPos, qtoken) := elemsAtNextValidPosTo_From_(dirOfMove, curQE)

  // Box treatment: it is done before ball movement, because it can block it
  if (isABox_(qtoken)) {
    GoToCell_(nextPos) // EQV-TO: GoToNextValidPosTo_From_(dirOfMove, curQE)
    TryToMoveCurrentBoxTo_(dirOfMove)
    GoToCell_(bpos(ball))
    qtoken := currentQToken() // QToken may have changed, as a result from moving the box (when successful)
    // TO-DO: add bouncing. 
    GoToCell_(bpos(ball))
  }

  // Ball moves
  if (isPortal_(curQE) && isBeamingBall_(ball)) // If beaming from a portal, traverse the portal to its target
    {                                           // It is first, to account for bouncing on stuck boxes at the target
      ClearBall()
      if (isABox_(qtoken)) { let (dirOfMove, ball) := (opposite(dirOfMove), bouncedBall_(ball))  }
      else                 { GoToCell_(nextPos) /* GoToNextValidPosTo_From_(dirOfMove, curQE) */ } // The portal target
      DrawMovingQBall_(beamedBall_(ball))
      ballChanged := True
    } 
  elseif (isOpen_(nextQE) && not isABox_(qtoken)) // If the ball can enter the next element, move it -- many triggers may occur
    {
      ClearBall()
      ConsiderTriggersLeavingAt_(curQE)
      if (isPortal_(curQE))  { /* TO-DO: Consider box bouncing */ }
      GoToNextValidPosTo_From_(dirOfMove, curQE)
      ConsiderTriggersForBallEnteringAt_MovingTo_With_(nextQE, dirOfMove, qtoken)
      if (isPortal_(nextQE)) { DrawMovingQBall_(beamingBall_(ball)) }
      else                   { DrawQBall_(ball)                     }
      ballChanged := True
    } 
  elseif (isPortal_(curQE)) // If leaving a portal, and there is no room, the ball bounces
    {
      ClearBall()
      ball := bouncedBall_(ball)
      DrawMovingQBall_(beamingBall_(ball))
      ballChanged := True
    } 
  elseif (moveContinues) // moveContinues implies that movement do not start in this step. So, stopping produce changes 
    {  
      ClearBall()
      if (isAJewel_(qtoken))   { GoToNextValidPosTo_From_(dirOfMove, curQE) // Jewel can be hit across borders...
                                 GrabJewel()
                                 GoToCell_(bpos(ball))
                               }
      DrawQBall_WithHintMDir_(stoppedBall_(ball), hintMDirForCurrentLevel())  // bpos(ball) is the current pos, because no movement occurs
      ballChanged := True
    } 
  else { ballChanged := False }  // Movement try to start, but there was no room to do it

  // Adjust TopBar
  if (ballChanged && not moveContinues) { AdjustTopNumMoves(); AdjustTopHintTo_(dirOfMove) }
}

// ---------
// Quell logic operations
// Level 2
// ---------
function dirOfMoveDeterminedBy_And_(ball, mdir) {
  /* PRECOND: movementOccursWith_(ball)And_(mdir), that is, ball is different from NoBall, and if it is not moving, mdir is not Nothing */
  return(choose goingTo(ball)  when (isMovingBall_(ball))
                fromJust(mdir) otherwise)
}

function elemsAtNextValidPosTo_From_(dir, qelem) {
  /* OBS: a valid pos QElem is different from a border (Limit or Angle) */
  GoToNextValidPosTo_From_(dir, qelem)
  return(currentQElem(), currentPos(), currentQToken())
}

procedure TryToMoveCurrentBoxTo_(dir) {
  /* PRECOND: there is a box in the current cell */
  let (nextQE, nextPos, qtoken) := elemsAtNextValidPosTo_From_(dir, currentQElem())
  if (isOpen_(nextQE) && not isABox_(qtoken) && not isAPearl_(qtoken) && not hasBall()) {
    let (box, pos, curQE) := (currentBox(), currentPos(), currentQElem())
    ClearBox()
    ConsiderTriggersLeavingAt_(curQE)
    GoToNextValidPosTo_From_(dir, curQE)
    ConsiderTriggersForBoxEnteringAt_MovingTo_(nextQE, dir)
    if (isPortal_(nextQE)) { DrawBeamingBox_(box) }
    else                   { DrawBox_(box)        }
    GoToCell_(pos)
  }
}

procedure ConsiderTriggersLeavingAt_(qelem) { 
  /* PRECOND: current cell has qelem. 
     OBS: the parameter is for efficiency
  */
  if (isGate_(qelem)) { CloseGate() }
} 

procedure ConsiderTriggersForBallEnteringAt_MovingTo_With_(qelem, dir, qtoken) {
  /* PRECOND: current cell has qelem and qtoken. 
     OBS: parameters qelem and qtoken are for efficiency
  */
  if (isAPearl_(qtoken)) { GrabPearl()             } 
  if (isAJewel_(qtoken)) { GrabJewel()             } 
  if (isSwitch_(qelem))  { RotateAllQElemsTo_(dir) } 
}

procedure ConsiderTriggersForBoxEnteringAt_MovingTo_(qelem, dir) {
  /* PRECOND: current cell has qelem. 
     OBS: parameter qelem is for efficiency
  */
  if (isSwitch_(qelem))  { RotateAllQElemsTo_(dir) }
}

procedure GoToNextValidPosTo_From_(dir,qelem) {
  if (isPortal_(qelem) && currentPortalIsBeaming()) 
       { GoToCell_(target(qelem))    } 
  else { Move(dir); CheckForBorder() }
}

// ---------
// Triggers
// ---------
procedure GrabPearl() {  // Must decrease numPearls and end in the initial cell
  /* PRECOND: the current cell contains a Pearl */
  ClearPearl()
  AdjustTopNumPearls()
}

procedure GrabJewel()          { ... } // Must decrease hits, see if found, and then mark jewelFound, remove the jewel, and end in the initial cell

procedure RotateAllQElemsTo_(dir) { 
  pos := currentPos()
  AdjustTopSpikesDirTo_(dir)
  AdjustAllRotableQElemsTo_(dir)
  GoToCell_(pos)
} 

procedure AdjustAllRotableQElemsTo_(dir) {
  StartBoardTraverseTo_And_(East, North)
  while (not atEndOfBoardTraverseTo_And_(East, North)) {
    RotateCurrentQElemTo_IfNeeded(dir)
    GoToNextCellInBoardTraverseTo_And_(East, North)
  }
}

procedure RotateCurrentQElemTo_IfNeeded(dir) {
  if (hasRotableQElem()) {
    ClearAttrA()
    DrawDir_With_(dir, attrAColor())
  }
}

// ---------
// Top level modifications
// ---------
procedure AdjustTopNumMoves()            {
  pos := currentPos()
  GoToTopNumMoves()
  numMoves := currentNumWith_(attrAColor())
  ClearTopNumMoves()
  DrawNum_With_(numMoves+1, attrAColor())
  GoToCell_(pos)
}

procedure AdjustTopHintTo_(dir) {
  pos := currentPos()
  GoToTopHint()
  currentNHint := currentMNumWith_(attrBColor())
  ClearTopHint()
  if (just(dir)==dHintForNHint_On_(currentNHint, level())) 
       { DrawMNum_With_(just(fromJust(currentNHint)-1), attrBColor()) }
  else { DrawMNum_With_(Nothing                       , attrBColor()) }
  GoToCell_(pos)
}

procedure AdjustTopNumPearls() { 
  pos := currentPos()
  GoToTopNumPearls()
  numPearls := currentNumWith_(attrAColor())
  ClearTopNumPearls()
  DrawNum_With_(numPearls-1, attrAColor())
  GoToCell_(pos)
}

procedure AdjustTopSpikesDirTo_(dir) { 
  /* OBS: does not return to initial cell, because it is used from one that does */
  // pos := currentPos()
  GoToTopSpikesDir()
  ClearTopSpikesDir()
  DrawMDir_With_(just(dir), attrAColor())
  // GoToCell_(pos)
}

// ---------
// Next QElement logic
// ---------
procedure CheckForBorder() {
  if (hasBorder()) {
    GoToMatchingBorderTo_(opposite(dir)) // Precondition guaranteed by global precondition and invariant representation of QLevel
    Move(dir) // current qelem cannot be a boarder or Corner, or board is not valid, guaranteed by global precondition and invariant representation of QLevel
  }
}

// ---------
// Quell element operations, on board
// ---------
procedure GoToMatchingBorderTo_(dir) { while (not hasBorder()) { Move(dir) } } /* PRECOND: there exists a matching border in the given direction */
procedure CloseGate()                { DrawBool_With_(True, attrBColor())     } /* PRECOND: there is an open Gate at the current cell */

function  currentPortalIsBeaming()   { return(hasPortal() && (hasBeamingBall() || hasBeamingBox())) }


{-
// ---------
// Quell operative functions
// ---------
function quell_WithOneStepTo_(quell, mdir) {
  /* OBS: If the ball is moving, dir is ignored. If there is no ball, there is nothing to do. */
  newQuell := quell
  if (hasMovingQBall_(newQuell) || stepAt_StartsMoveTo_(newQuell, mdir)) {
    // Determine the direction of movement, and adjust solution if a movement starts
    if (hasMovingQBall_(newQuell)) 
      { dirOfMove := fromJust(dirOfBallOn_(newQuell)) }
    else
      { dirOfMove := fromJust(mdir)
        newQuell  := quell_WithAdjustedSolutionFor_(newQuell, dirOfMove)
      }

    let (curPos, curQE)   := currentDataOn_(newQuell)      
    let (nextPos, nextQE) := nextDataOn_From_To_(newQuell, curPos, dirOfMove)

   // COMPLETAR     
   //    If nextQE is a box, calculate its immediate next      
   // Mejorar el análisis de adjusted
   // let (dirOfMove, nextQE, nextPos) :=  adjusted_And_In_WRT_In_On_(dirOfMove, nextQE, nextPos, curQE, curPos, newQuell)
    
    action       := whatHappensIn_MovingTo_On_(nextQE, dirOfMove, newQuell)
    globalAction := globalActionFrom_On_(nextQE, newQuell)
    newQuell     := afterAction_On_With_At_And_At_To_(action, newQuell, curQE, curPos, nextQE, nextPos, dirOfMove)
    newQuell     := afterGlobal_On_(globalAction, newQuell)
  }
  return(newQuell)
}

function quell_WithAdjustedSolutionFor_(quell, dirOfMove) {
  /* PRECOND: there is a ball */
   newSolution := solution(quell)
   if (not isEmpty(newSolution) && head(newSolution) == dirOfMove)
        { newSolution := tail(newSolution) }
   else { newSolution := []                }
   return(QuellLevel(quell | solution <- newSolution, numMoves <- numMoves(quell) + 1))
}

// ---------
// Topological determination of data
// ---------
function currentDataOn_(quell) {
  pos := ballPosOn_(quell)
  return(pos, elemAtPos_In_(pos, board(quell)))
}

function nextDataOn_From_To_(quell, pos, dir) {
  /* PURPOSE: calculates the next position and element for balls AND boxes */
  let (nextPos, nextQE) := neighborDataOn_From_To_(quell, pos, dir)

  // The next of a limit is the next of the matching limit. This control has to be first, in case that next is a Portal
  if (isLimit_(nextQE)) {
    newPos  := matchingLimitFor_At_To_In_(nextQE, nextPos, dir, board(quell))
    nextPos := nextPosOf_To_(newPos, dir)      
    nextQE  := elemAtPos_In_(nextPos, board(quell))
  }

  // Entering a portal always ends in the target
  if (isPortal_(nextQE)) {
    nextPos := targetOf_From_(nextQE, nextPos)
    nextQE  := elemAtPos_In_(nextPos, board(quell))
  }

  return (nextPos, nextQE)
}

function neighborDataOn_From_To_(quell, pos, dir) {
  neighPos := nextPosOf_To_(pos, dir)
  return(neighPos, elemAtPos_In_(neighPos, board(quell)))
}

// ---------
// Other
// ---------
function adjusted_And_In_WRT_In_On_(dir, next, nextPos, current, curPos, quell) {
  /* OBS: the 3 checks are sequential to allow complex configurations (i.e. a portal besides another portal with a Limit besides its target) */
  curDir      := dir
  curlNextPos := nextPos
  curlNext    := next
  
  if (isPortal_(current) && isBlocking_(curNext) && not isDangerous_From_On_(curNext, curDir, quell)) {
    curDir     := opposite (curDir)
    newPos     := targetOf_From_(current, curPos)
    curNextPos := nextPosOf_To_(newPos, curDir)
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  }
  
  if (isPortal_(curNext)) {
    curNextPos := targetOf_From_(curNext, curNextPos)
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  } 

  if (isLimit_(curNext)) {
    newPos     := matchingLimitFor_At_To_In_(curNext, curNextPos, curDir, board(quell))
    curNextPos := nextPosOf_To_(newPos, curDir)      
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  }
  
  return (curDir, curNext, curNextPos)
}

function whatHappensIn_MovingTo_On_(qelem, dir, quell) {
  return (choose Pop  when (isDangerous_From_On_(qelem, dir, quell))
                 Stay when (isBlocking_(qelem))
                 Move otherwise
  )
}

function globalActionFrom_On_(qelem, quell) {
  return (matching (qelem) select
            spikesDir(quell) on Switch
            Nothing          otherwise)
}

function afterAction_On_With_At_And_At_To_(action, quell, current, curPos, next, nextPos, dir) {
    switch (action) {
       Pop  -> { newQuell := QuellLevel(quell | inTransit <- Nothing, ball <- Nothing) }
       Stay -> { newQuell := QuellLevel(quell | inTransit <- Nothing)
                 newQuell := withAdjustedJewelAt_On_(nextPos, newQuell)
               }
       Move -> { newQuell := QuellLevel(quell| inTransit <- just(dir), ball <- just(nextPos))
                 newQuell := withNew_At_And_At_To_On_(current, curPos, next, nextPos, dir, newQuell)
                 newQuell := withAdjustedJewelAt_On_(nextPos, newQuell)
               }
     }
    return (newQuell)
}

function afterGlobal_On_(gaction, quell) {
    return (matching (gaction) select
              QuellLevel(quell | spikesDir <- fromJust(gaction)) on Just
              quell                                              otherwise)
}

function withNew_At_And_At_To_On_(current, curPos, next, nextPos, dir, quell) {
   newCurrent := elem_AfterLeaving(current)
   newNext    := elem_AfterEnterFrom_(next, dir)
   newBoard   := set_AtPos_To_(set_AtPos_To_(board(quell)
                                           , curPos, newCurrent)
                             , nextPos, newNext)
   return (QuellLevel(quell | board     <- newBoard
                            , numPearls <- adjustPearls(numPearls(quell), next))
      )
 }

function withAdjustedJewelAt_On_(pos, quell) {
  jewel    := jewel(quell)
  hits     := hitsReceived(jewel)
  newJewel := QJewel(jewel | hitsReceived <- (1+hits) mod 3
                          , found <- hits==2)
  return (choose QuellLevel (quell | jewel <- newJewel)  when (not found(jewel) && pos==jpos(jewel))
                 quell                                   otherwise)
}
           
function elem_AfterEnterFrom_(qelem, dir) {
  return (matching (qelem) select
            Empty on Pearl
            qelem otherwise)
}

function elem_AfterLeaving(qelem) {
  return (matching (qelem) select
            Gate(open <- False) on Gate
            qelem               otherwise
  )
}

function adjustPearls (num, qelem) {
  return(matching (qelem) select
           num-1 on Pearl
           num otherwise)
}

// ---------
// Basic Quell functions
// ---------
function stepAt_StartsMoveTo_(quell, mdir) { return (hasQBall_(quell) && not ballOn_IsMoving(quell) && not isNothing(mdir)) }

function isDangerous_From_On_(qelem, dir, quell) {
  return(matching (qelem) select
           dirOfSpikesOf_At_(qelem, quell)==opposite(dir) on Spike
           True                                           on Multispike
           False                                          otherwise)
}

function dirOfSpikesOf_At_(qelem, quell) {
  /* PRECOND: qelem is a Spike */
  return(choose spikesDir(quell)             when (isRotable_(qelem))
                fromJust(notRotable(qelem)) otherwise)
}

function isBlocking_(qelem) {
  return(matching (qelem) select
           True            on Wall
           True            on Spike
           True            on Multispike
           not open(qelem) on Gate
           False           otherwise)
}

function targetOf_From_(qportal, pos) {
  /* PRECOND: * qportal is a Portal */
 return (choose doorA(qportal) when (doorB(qportal)==pos)
                doorB(qportal) when (doorA(qportal)==pos)
                pos            otherwise)
}

// ---------
// Functions for Limits
// ---------
function matchingLimitFor_At_To_In_(qelem, pos, dir, board) {
  /* PRECOND:
       * the qelem in board at pos is a Limit pointing to other limit
       * board is the board of a valid QLevel
  */
 return(choose
          Pos (row <- row(pos)
              ,col <- indexOfLimitNotAt_In_(col(pos), elemAtIndex_In_(row(pos), board)))    when (isHorizontal(dir)) 
          Pos (row <- indexOfLimitNotAt_In_(row(pos), column_Of_(col(pos)     , board))
              ,col <- col(pos))                                                             otherwise)
}

function indexOfLimitNotAt_In_(idx, qs) {
  /* PRECOND: * there are at least two Limits in qs pointing to each other, one of them at pos */
  let (before, qelem, after) := split_At_(qs, idx)
  Assert_OrFail_ (isLimit_(qelem), msgNotALimit())
  if (pointsBackwards_(qelem)) 
       { let (matchingIdx, matchingQE) := firstLimitBackwardsIn_(before)
         Assert_OrFail_(pointsForwards_(matchingQE), msgMalformedBoard())
       }
  elseif (pointsForwards_(qelem)) 
       { let (matchingIdx, matchingQE) := firstLimitForwardsIn_(after)
         Assert_OrFail_(pointsBackwards_(matchingQE), msgMalformedBoard())
         matchingIdx := matchingIdx + idx + 1
       }
  else { BOOM(msgNotABorder()) }
  return(matchingIdx)
}

function pointsBackwards_(qelem) {
  dir := pointsTo(qelem)
  return(dir == just(South) || dir == just(West))
}

function pointsForwards_(qelem) {
  dir := pointsTo(qelem)
  return(dir == just(North) || dir == just(East))
}

function firstLimitBackwardsIn_(qs) {
  /* PRECOND: qs has a Limit */
  let (idx, qelem) := firstLimitForwardsIn_(reverse(qs))
  return (idx+lengthOf_(qs)-1, qelem)
}

function firstLimitForwardsIn_(qs) {
  /* PRECOND: qs has a Limit */
   idx     := 0
   qelem   := head(qs)
   current := tail(qs)
   while(not isLimit_(qelem)) {
     idx     := idx + 1
     qelem   := head(current)
     current := tail(current)
   }
   return(idx, qelem)
}
-}
// ---------
// Error messages
// ---------
function msgMalformedBoard() { return(babel("Malformed board", "Tablero mal formado"))          }
function msgNotALimit()      { return(babel("QElement at the given position is not a Limit"
                                          , "El QElement en la posición dada no es un Límite")) }
function msgNotABorder()     { return(babel("Limit at the given position is not a border"
                                          , "El Límite en la posición dada no es un borde"))    }
/* ============================================================================================================
   END Quell-Logic.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Model.gbs
   Definition of the datatypes representing a Quell level.
   
   It is assumed that there is a single function level() that encodes the initial state of the level.
   All the static information is obtained from it (particularly, isTutorial, solution, and minMoves).

// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
   ============================================================================================================
*/

type QuellLevel is record {
  /* INV.REP.:
   * board represent the Quell game-board
     - all elements of the game-board are borders of the same length
     - boarders (Limits and Angles) and Corners form a continuous "line"
     - all rows or columns that have some element different from Out or a limit have at least a two paired borders (Limits or Angles pointing to each other) 
     - all elements different from Out or boarders or Corner are between paired borders
     - no Out or border or Corner elements are between paired borders
     - for each Portal on the board, its target is a valid pos with the only other Portal with matching id on the board
   * solution is a list of Dirs of length minMoves that solves the level
   * minMoves is the minimum number of moves required to solve the level using Quell rules (0 if not solvable)
   * if the jewel field jpos exists, then it indicates a valid position in the board, and the QElem in that position is either Wall or Empty
   * either there is some RotableSpikes, at least a Switch, and spikesDir is different from Nothing, 
     or there is no RotableSpikes, no Switches, and spikesDir is Nothing
   * all pos values in boxes are valid positions in the board, and the QElement in that position is Empty
   * if the ball field bpos exists, then it indicates a valid position in the board, and the QElem in that position is either Empty, or an open Gate, or a Portal, or a Switch
   * if rightMoves is not Nothing, the number is positive and less than minMoves
   */
   field isTutorial    // Bool
   field board         // [[QElem]] 
   field solution      // [Dir]
   field minMoves      // Number
   field jewel         // QJewel
   field spikesDir     // Maybe(Direction)
   field boxes         // [(Pos, Gender)]
   field ball          // QBall
   field numMoves      // Number
   field rightMoves    // Maybe(Number)
   field numPearls     // Number
}

type QElem is variant {
   case Empty        {}
   case Pearl        {}
   case Wall         {}
   case Corner       { field dir }        // Dir
   case Angle        { field dir }        // Dir
   case Limit        { field pointsTo }   // Dir
   case Portal       { field id           // Number (less than 10)
                       field target       // Pos
                     }
   case Gate         { field closed }     // Bool
   case Spike        { field pointsTo }   // Dir
   case Multispike   {}
   case RotableSpike {}
   case Switch       {} 
   case Out          {}
}

type QJewel is variant {
   case NoJewel {}
   case QJewel  { field jpos // Pos
                  field hits // Number (usually 4 if Wall, and 1 if visible)
                }
}

type QBall is variant {
   case NoBall  {}
   case QBallAt { field bpos }  // Pos
   case QBallTo { field bpos    // Pos
                  field goingTo // Dir 
                  field beaming // Bool
                }
}

type QToken is variant {
  case ABox    {}
  case APearl  {}
  case AJewel  {}
  case NoToken {}
}

// ---------------------------
//  Abbreviations
// ---------------------------
function cNW() { return(Corner(dir <- East))      }
function cNE() { return(Corner(dir <- South))     }
function cSE() { return(Corner(dir <- West))      }
function cSW() { return(Corner(dir <- North))     }
   
function aNW() { return(Angle(dir <- East))       }
function aNE() { return(Angle(dir <- South))      }
function aSE() { return(Angle(dir <- West))       }
function aSW() { return(Angle(dir <- North))      }

function hT()  { return(Limit(pointsTo <- South)) }
function hB()  { return(Limit(pointsTo <- North)) }
function vL()  { return(Limit(pointsTo <- East))  }
function vR()  { return(Limit(pointsTo <- West))  }

// ---------------------------
//  Detection functions
// ---------------------------
function isEmpty_(qelem)        { return(matching (qelem)  select True  on Empty        False otherwise) }
function isPearl_(qelem)        { return(matching (qelem)  select True  on Pearl        False otherwise) }
function isWall_(qelem)         { return(matching (qelem)  select True  on Wall         False otherwise) }
function isCorner_(qelem)       { return(matching (qelem)  select True  on Corner       False otherwise) }
function isAngle_(qelem)        { return(matching (qelem)  select True  on Angle        False otherwise) }
function isLimit_(qelem)        { return(matching (qelem)  select True  on Limit        False otherwise) }
function isPortal_(qelem)       { return(matching (qelem)  select True  on Portal       False otherwise) }
function isGate_(qelem)         { return(matching (qelem)  select True  on Gate         False otherwise) }
function isSpike_(qelem)        { return(matching (qelem)  select True  on Spike        False otherwise) }
function isMultispike_(qelem)   { return(matching (qelem)  select True  on Multispike   False otherwise) }
function isRotableSpike_(qelem) { return(matching (qelem)  select True  on RotableSpike False otherwise) }
function isSwitch_(qelem)       { return(matching (qelem)  select True  on Switch       False otherwise) }
function isOut_(qelem)          { return(matching (qelem)  select True  on Out          False otherwise) }

function isOpen_(qelem)         { return(matching (qelem)  select True              on Empty
                                                                  True              on Portal
                                                                  True              on Switch
                                                                  not closed(qelem) on Gate
                                                                  False otherwise)                       } 

// --------------------------- 
function isNoJewel_(jewel)      { return(matching (jewel)  select True  on NoJewel           False otherwise) }
function isJewel_(jewel)        { return(matching (jewel)  select True  on QJewel            False otherwise) }
      
// ---------------------------      
function isNoBall_(qball)       { return(matching (qball)  select True  on NoBall            False otherwise) }
function isBall_(qball)         { return(matching (qball)  select False on NoBall            True  otherwise) }
function isStaticBall_(qball)   { return(matching (qball)  select True  on QBallAt           False otherwise) }
function isMovingBall_(qball)   { return(matching (qball)  select True  on QBallTo           False otherwise) }
function isBeamingBall_(qball)  { return(matching (qball)  select beaming(qball) on QBallTo  False otherwise)}

// ---------------------------
function isNoToken_(qtoken)     { return(matching (qtoken) select True  on NoToken           True  otherwise) }
function isABox_(qtoken)        { return(matching (qtoken) select True  on ABox              False otherwise) }
function isAPearl_(qtoken)      { return(matching (qtoken) select True  on APearl            False otherwise) }
function isAJewel_(qtoken)      { return(matching (qtoken) select True  on AJewel            False otherwise) }

// ---------------------------
//  Ball modification
// ---------------------------
function movedBall_To_(qball,dir) { return(QBallTo(bpos    <- bpos(qball)
                                                  ,goingTo <- dir
                                                  ,beaming <- False))                            } /* PRECOND: isBall_(qball)       */
function stoppedBall_(qball)      { return(QBallAt(bpos <- bpos(qball)))                         } /* PRECOND: isBall_(qball)       */
function bouncedBall_(qball)      { return(QBallTo(qball | goingTo <- opposite(goingTo(qball)))) } /* PRECOND: isMovingBall_(qball) */
function beamedBall_(qball)       { return(QBallTo(qball | beaming <- False))                    } /* PRECOND: isMovingBall_(qball) */
function beamingBall_(qball)      { return(QBallTo(qball | beaming <- True))                     } /* PRECOND: isMovingBall_(qball) */

// ---------------------------
//  Jewel information on Quell
// ---------------------------
function hasJewel_(quell)      { return(not isNoJewel_(jewel(quell))) }
function jewelPosOn_(quell)    { return(jpos(jewel(quell)))           } /* PRECOND: * hasJewel_(quell) */     

// ---------------------------
//  Ball information on Quell
// ---------------------------
function hasBall_(quell)       { return(not isNoBall_(ball(quell))) }
function hasMovingBall_(quell) { return(isMovingBall_(ball(quell))) }
function ballPosOn_(quell)     { return(bpos(ball(quell)))          } /* PRECOND: * hasBall_(quell) */     
function ballDirOn_(quell)     { return(goingTo(ball(quel)))        } /* PRECOND: hasMovingBall_(quell) */ 
function ballBeamingOn_(quell) { return(beaming(ball(quel)))        } /* PRECOND: hasMovingBall_(quell) */ 

// ---------------------------
//  Hint information on Quell
// ---------------------------
function firstTutorialDHintOn_(quell) {
  return(choose just(head(solution(quell))) when (isTutorial(quell))
                Nothing otherwise)
}

function dHintOn_(quell) {
  return(choose just(elemAtIndex_In_(fromJust(rightMoves(quell))
                                    ,solution(quell)))           when (not isNothing(rightMoves(quell)))
                Nothing                                          otherwise)
}

function nHintOn_(quell) {
  return(choose just(minMoves(quell)-fromJust(rightMoves(quell))) when (not isNothing(rightMoves(quell)))
                Nothing                                           otherwise)
}

function dHintForNHint_On_(mi, quell) { 
  return(choose just(elemAtIndex_In_(minMoves(quell)-fromJust(mi)
                                    ,solution(quell)))            when (not isNothing(mi) && mi/=just(0))
                Nothing                                           otherwise)
}

/* ============================================================================================================
   END Quell-Model.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Operations.gbs
   Operations to perform a step of movement (with all the needed changes)
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
// REQUIRE: Quell-Representation.gbs
// REQUIRE: Quell-Drawing.gbs
// REQUIRE: Quell-Reading.gbs
// REQUIRE: Quell-Logic.gbs
   ============================================================================================================
*/
// ---------
// Quell top level operations
// ---------
procedure DrawQuell_(quell) { DrawQLevel_(quell) }       /* PRECOND: Gobstones board is big enough to represent the quell board and the top bar */

procedure ProcessOneStepTo_(dir) { ProcessStepTo_(just(dir)) }
procedure ProcessOneStep()       { ProcessStepTo_(Nothing)   }

/* ============================================================================================================
   END Quell-Operations.gbs
   ============================================================================================================
*/

/* ============================================================================================================
   START Quell-Reading.gbs
   Operations to read a Quell level from the board. Awareness of Quell-Representation is needed
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
// REQUIRE: Quell-Representation.gbs
   ============================================================================================================
*/

// ---------
// Reading operations
// OBS: All operations has as PRECOND:
//        * there is a quell level represented in the Gobstones board 
// ---------
function currentQBall() {
  code := currentNumWith_(ballColor())
  pos  := currentPos()
  return (choose
    NoBall when (code==0)
    QBallTo(bpos <- pos, goingTo <- decodedDir_(code)   , beaming <- False) when (num_IsBetween_And_(code,  1,  4))
    QBallTo(bpos <- pos, goingTo <- decodedDir_(code-10), beaming <- True)  when (num_IsBetween_And_(code, 11, 14))
    QBallAt(bpos <- pos)                                                    otherwise) // ballColor stones are between 5 and 9
}

function currentQElemTo_(dir) { Move(dir); return (currentQElem()) } /* PRECOND: there is a cell to dir */
function currentQElem() {
  /* PRECOND: * there is a qelem represented in the current cell */
  return(matching (numStones(qelemColor())) select
          Empty                 on 0
          currentCorner()       on 1
          currentAngle()        on 2
          currentLimit()        on 3
          currentPortal()       on 4
          currentGate()         on 5
          currentSpike()        on 6
          Multispike            on 7
          RotableSpike          on 8
          Switch                on 9
          Wall                  on 10
          Out                   on 11
          boom(msgNoQElement()) otherwise)
}

function currentQToken() {
  return(choose ABox    when (hasBox())
                APearl  when (hasPearl())
                AJewel  when (hasJewel())
                NoToken otherwise)
}

function currentBox() {
  /* PRECOND: there is a Box represented in the current cell 
     OBS: boxes are represented simply by their Gender
  */
  code := currentNumWith_(attrBColor()) div 100
  return (decodeGender_(code))
}

// ---------
// Reading specific QElems
// ---------
function currentCorner() { return(Corner(dir      <- currentDirWith_ (attrAColor()))) } /* PRECOND: * there is a  corner represented in the current cell */
function currentAngle()  { return(Angle (dir      <- currentDirWith_ (attrAColor()))) } /* PRECOND: * there is an angle  represented in the current cell */
function currentLimit()  { return(Limit (pointsTo <- currentDirWith_ (attrAColor()))) } /* PRECOND: * there is a  limit  represented in the current cell */
function currentSpike()  { return(Spike (pointsTo <- currentDirWith_ (attrAColor()))) } /* PRECOND: * there is a  spike  represented in the current cell */
function currentGate()   { return(Gate  (closed   <- currentBoolWith_(attrBColor()))) } /* PRECOND: * there is a  gate   represented in the current cell */
function currentPortal() { return(Portal(target   <- currentPosWith_(attrAColor())
                                       , id       <- currentNumWith_(attrBColor())))  } /* PRECOND: * there is a  portal represented in the current cell */


// ---------
// Detecting QElems
// ---------
function hasBall() {
  ballCode := numStones(ballColor())
  return(ballCode > 0)
}

function hasBeamingBall() {
  /* PRECOND: current cell has a Portal */
  ballCode := numStones(ballColor())
  return(ballCode > 10)
}

function hasBorder() {
  /* OBS: a border is either an Angle or a Limit */
  qelemId := numStones(qelemColor())
  return(qelemId == 2 || qelemId == 3)
}

function hasPortal() {
  qelemId := numStones(qelemColor())
  return(qelemId == 4)
}

function hasBeamingBox() {
  /* PRECOND: current cell has a Portal */
  boxCode := truncate_ToMultipleOf_(numStones(attrBColor()), 10)
  return(boxCode==110 || boxCode==210) 
}

function hasRotableQElem() {
  qelemId := numStones(qelemColor())
  return(qelemId==8 || qelemId==9)
}

function hintMDirForCurrentLevel() { return(dHintForNHint_On_(currentNHint(), level())) }
function currentNHint() {
  /* OBS: the if-then-else is used to avoid moving when is not a tutorial, for efficiency */
  if (isTutorial(level())) { GoToTopHint()
                             currentNHint := currentMNumWith_(attrBColor())
                           }
  else                     { currentNHint := Nothing }
  return (currentNHint)
}

// ---------
// Detecting QTokens
// ---------
function hasBox()   { 
  /* OBS: boxes are represented with 10 to 40 stones, bur there can be some more for other things (from Portals)
          (boxes may appear on Empty, Switch, Portals, and open Gate)
  */
  return(numStones(attrBColor())>=10) 
}

function hasPearl() {
  /* OBS: pearls appear only on Empty */
  qelemId := numStones(qelemColor())
  return(qelemId==0 && numStones(attrBColor())==1) 
}

function hasJewel() {
  /* OBS: jewels appear only on Empty or Wall */
  qelemId := numStones(qelemColor())
  return ((qelemId==0 || qelemId==10) && hasStones(attrAColor()))
}

// ---------
// Error messages
// ---------
function msgNoQElement() { 
  return(babel("There is no QElement represented in the current cell"
              ,"No hay un QElement representado en la celda actual"))
}
/* ============================================================================================================
   END Quell-Reading.gbs
   ============================================================================================================
*//* ============================================================================================================
   START Quell-Representation.gbs
   Coding colors and explanation of representation for QuellLevels
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
   ============================================================================================================
*/

// ---------
// Representation
// ---------
/*
  QLevel info is represented at top row with 10x qelem stones (x the col Number) 
    * cell  1 at column 1 encode numMoves in attrA stones (100 for overload)
    * cell  2 at column 2 encode minMoves in attrA stones (up to 29 -- more are ignored)
    * cell  3 at column 2 from East encode jewelFound in attrB stones
    * cell  4 at column 1 from East encode numPearls  in attrA stones
                                       and rightMoves in attrB stones
    * cell  0 at East edge encode spikesDir in attrA stones

  QElements are represented with qelemColor() stones, and their attributes with attrAColor() and attrBColor() stones, depending of the case.
    + Empty       ,  no qelem stones
    + Corner      ,  1 stone   * dir      , attrA stones
    + Angle       ,  2 stones  * dir      , attrA stones
    + Limit       ,  3 stones  * pointsTo , attrA stones 
    + Portal      ,  4 stones  * target   , attrA stones
                               * id       , attrB stones
    + Gate        ,  5 stones  * clsed    , attrB stones
    + Spike       ,  8 stones  * dir      , attrA stones 
    + Multispike  ,  9 stones
    + Switch      ,  6 stones  * spikesDir, attrA stones
    + Rotablespike,  7 stones  * spikesDir, attrA stones
    + Wall        , 10 stones
    + Out         , 11 stones

  QTokens are represented with attrAColor() and attrBColor(), in such a way as to avoid clashing with each other or the qelems they may appear in
    + Pearl                    *       1 attrB stones 
    + Box                      * gender, 100*attrB stones (must be equal to Pearl representation, and different from attributes at Gates, Portals or Switches)
                                         10+ for beaming boxes
    + Jewel                    * hits  , attrA stones (must be different from Pearl representation, because it may also appear on Empty)
  
  The ball is represented with ballColor() stones 
    + moving North                 ,  1 stone
    + moving East                  ,  2 stones
    + moving South                 ,  3 stones
    + moving West                  ,  4 stones
    + not moving                   ,  5 stones
    + not moving with hint to North,  6 stones (5+1)
    + not moving with hint to East ,  7 stones (5+2)
    + not moving with hint to South,  8 stones (5+3)
    + not moving with hint to West ,  9 stones (5+4)
    + beaming while moving North   , 11 stones (10+1)
    + beaming while moving East    , 12 stones (10+2)
    + beaming while moving South   , 13 stones (10+3)
    + beaming while moving West    , 14 stones (10+4)
*/

procedure GoToTopNumMoves()  { GoToCorner__(North, West); Move(East)           }
procedure GoToTopJewel()     { GoToCorner__(North, East); Move__Times(West, 2) }
procedure GoToTopNumPearls() { GoToCorner__(North, East); Move(West)           }
procedure GoToTopHint()      { GoToCorner__(North, East); Move(West)           }
procedure GoToTopSpikesDir() { GoToCorner__(North, East)                       }

// ---------
// Colors
// ---------
function ballColor()  { return(Blue)  }
function qelemColor() { return(Black) }
function attrAColor() { return(Green) }
function attrBColor() { return(Red)   }

// ---------
// Codes
// ---------
function codeOfQelem_(qelem) {
  return (matching (qelem) select
             0 on Empty
             0 on Pearl   // Pearls are always on Empty cells, and drawn with attribute colors
             1 on Corner
             2 on Angle
             3 on Limit
             4 on Portal
             5 on Gate
             6 on Spike
             7 on Multispike
             8 on RotableSpike
             9 on Switch
            10 on Wall
            11 on Out
            boom(msgNotExpected("QElem")) otherwise
  )
}
/* ============================================================================================================
   END Quell-Representation.gbs
   ============================================================================================================
*/
