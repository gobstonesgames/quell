/* ============================================================================================================
   START Babel.gbs
   Code for using English names on Gobstones programs, even when the language is still not internationalized
   ============================================================================================================
*/

function language() { return(English) }

procedure Assert_OrFail_(condition, msg) { if (not condition) { BOOM(msg) } }
procedure ClearBoard()  { VaciarTablero() }

// ---------
// Internationalization
// ---------
type Language is variant {
  case English {}
  case Spanish {}
}

function babel(msgEn, msgSp) { 
  return(matching (language()) select 
           msgSp on Spanish
           msgEn otherwise)
}

// Colors
type Colour is variant {
    case Red    {}
    case Green  {}
    case Blue   {}
    case Black  {}
}

function colorEn2Sp(color) {
  return(matching (color) select
           Rojo   on Red
           Verde  on Green
           Azul   on Blue
           Negro  on Black
           boom(msgNotExpected("Colour")) otherwise)
}

function colorSp2En(color) {
  return(matching (color) select
           Red   on Rojo    
           Green on Verde   
           Blue  on Azul   
           Black on Negro
           boom(msgNotExpected("Color")) otherwise)
}

function hasStones(color) { return(hayBolitas(colorEn2Sp(color))) }
function numStones(color) { return(nroBolitas(colorEn2Sp(color))) }

procedure Drop(color) { Poner(colorEn2Sp(color)) }
procedure Grab(color) { 
    Assert_OrFail_(hasStones(color), msgNoStones())
    Sacar(colorEn2Sp(color)) 
}

function nextColor(color)  { return(colorSp2En(siguiente(colorEn2Sp(dir)))) }
function prevColor(color)  { return(colorSp2En(previo(colorEn2Sp(dir))))    }

function minColour() { return(colorSp2En(minColor())) }
function maxColour() { return(colorSp2En(maxColor())) }

// Directions
type Direction is variant {
    case North {}
    case East  {}
    case South {}
    case West  {}
}

function dirEn2Sp(dir) {
  return(matching (dir) select
           Norte on North
           Este  on East
           Sur   on South
           Oeste on West
           boom(msgNotExpected("Direction")) otherwise)
}

function dirSp2En(dir) {
  return(matching (dir) select
           North on Norte
           East  on Este 
           South on Sur  
           West  on Oeste
           boom(msgNotExpected("Dirección")) otherwise)
}

function canMove(dir) { return(puedeMover(dirEn2Sp(dir))) }

procedure Move(dir) { 
  Assert_OrFail_(canMove(dir), msgNoCells())
  Mover(dirEn2Sp(dir))     
}

procedure GoToEdge(dir) { IrAlBorde(dirEn2Sp(dir)) }

function opposite(dir) { return(dirSp2En(opuesto(dirEn2Sp(dir))))   }
function nextDir(dir)  { return(dirSp2En(siguiente(dirEn2Sp(dir)))) }
function prevDir(dir)  { return(dirSp2En(previo(dirEn2Sp(dir))))    }

function minDirection() { return(dirSp2En(minDir())) }
function maxDirection() { return(dirSp2En(maxDir())) }

// Directions
function isEmpty(xs) { return(esVacía(xs)) }
function head(xs)    { return(primero(xs)) }
function tail(xs)    { return(resto(xs))   }

// ERROR MESSAGES
function msgNoStones() { 
  return(babel("Cannot grab stones: there are no stones of that color"
              ,"No puedo sacar bolitas: no hay bolitas de ese color"
              ))
}

function msgNoCells() { 
  return(babel("Cannot move: there are no cells on that direction"
              ,"No puedo mover hacia ahí: no hay celdas en esa dirección"
              ))
}

function msgNotExpected(element) { 
  return(babel("CANNOT HAPPEN: " ++ element ++ " has changed?"
              ,"NO PUEDE SUCEDER: ¿cambió " ++ element ++ "?"
              ))
}
/* ============================================================================================================
   END Babel.gbs
   ============================================================================================================
*/

/* ============================================================================================================
   START Prelude.gbs
   General useful operations for a number of conveniencies
// REQUIRE: Babel.gbs
   ============================================================================================================
*/

// ---------
// Gobstones auxiliary functions
// ---------
procedure GoToCorner__(dir1, dir2) {
  /* PRECOND:
      * dir1 and dir2 are not equal and not opposite of each other
  */                                            
  GoToEdge(dir1)
  GoToEdge(dir2)
}

procedure Drop__Times(color, num) { repeat (num) { Drop(color) } }
procedure Grab__Times(color, num) { repeat (num) { Grab(color) } }
procedure Move__Times(dir, num)   { repeat (num) { Move(dir)   } }

procedure GrabAll(color) { Grab__Times(color, numStones(color)) }
procedure ClearCell() { foreach color in [minColour()..maxColour()] { GrabAll(color) } }

function isHorizontal(dir) { return (dir==East  || dir==West)  }
function isVertical(dir)   { return (dir==North || dir==South) }

function adjust_To_(val, max)             { return ((val+max) mod max) }
function num_IsBetween_And_(n, low, high) { return(n>=low && n<=high)  }

function delta(b) {
  return (choose 1 when (b)
                 0 otherwise) 
}

// ---------
// Coding functions 
// ---------

// Dir
procedure DrawDir_With_(dir, color) { Drop__Times(color, codeOfDir_(dir)) }
function codeOfDir_(dir) {
  return (matching (dir) select
            1 on North
            2 on East
            3 on South
            4 on West
            boom(msgNotExpected("Direction")) otherwise)
}

function currentDirWith_(color) {
  /* PRECOND: * there is a Dir represented (between 1 to 4 color stones) */
  return(decodedDir_(numStones(color)))
}

function decodedDir_(code) {
  /* PRECOND: * code is the coding of a Dir (between 1 and 4) */
  return(matching (code) select
           North on 1
           East  on 2
           South on 3
           West  on 4
           boom(msgNotACodeFor_("Direction")) otherwise)
}

// Bool
procedure DrawBool_With_(b, color) { Drop__Times(color, codeOfBool_(b)) }
function codeOfBool_(b) {
  return (choose 1 when (b)
                 0 otherwise)
}

function currentBoolWith_(color) {
  /* PRECOND: * there is a bool represented in the current cell with the given color */
  return(decodedBool_(numStones(color)))
}

function decodedBool_(code) {
  /* PRECOND: * code is the coding of a Bool (either 0 or 1) */
  return(matching (code) select
           True   on 1
           False  on 0
           boom(msgNotACodeFor_("Bool")) otherwise)
}

// ---------
// Pairs
// ---------
function fst(pair) {
    return(matching (pair) select 
               x on (x,y)
               boom("Cannot happen") otherwise)
}

function snd(pair) {
    return(matching (pair) select 
               y on (x,y)
               boom("Cannot happen") otherwise)
}

// ---------
// Maybe 
// ---------
type Maybe is variant {
  case Nothing  {}
  case Just     { field fromJust }  
}

function isNothing(mv) {
  return(matching (mv) select
           True on Nothing
           False otherwise)
}

function just(elem) {
  return (Just(fromJust <- elem))
}

function firstOf_Or_(md1, md2) {
 /* PRECOND: * md1 and md2 are not both Nothing */
 return(matching (md1) select
          fromJust(md1) on Just
          fromJust(md2) otherwise)
}


procedure DrawMNum_With_(mNum, color) {
  Drop__Times(color
            , matching (mNum) select
                1 + fromJust(mNum) on Just
                0                  otherwise
  )
}

function currentMNumWith_(color) {
  return (choose
            Nothing                   when (numStones(color) == 0)
            just(numStones(color)-1)  otherwise)
}

procedure DrawMDir_With_(mdir, color) {
  Drop__Times(color, codeOfMDir_(mdir))
}

function codeOfMDir_(mdir) {
  return (matching (mdir) select codeOfDir_(fromJust(mdir)) on Just
                                 5                          otherwise)
}

function currentMDirWith_(color) {
  /* PRECOND:
       * there is a MDir represented (between 1 to 5 color stones)
  */
  return(choose Nothing                      when (numStones(color)==5)
                just(currentDirWith_(color)) otherwise)
}

// ---------
// Pos
// ---------
type Pos is record {
   field row    // Number
   field col    // Number
}

function pos(r, c) { return(Pos(row <- r, col<-c)) }

procedure GoToCell_(pos) {
  GoToEdge(West)      
  Move__Times(East, col(pos))   
  GoToEdge(South)  
  Move__Times(North, row(pos))    
}

function currentPos() {
  return(Pos(row <- rowIndex()
            ,col <- colIndex()))
}

function rowIndex() { return(distanceToEdge_(South)) }
function colIndex() { return(distanceToEdge_(West))  }

function distanceToEdge_(dir) {
  measured := 0
  while (canMove(dir)) { Move(dir); measured := measured+1 }
  return (measured)
}

function nextPosOf_To_(pos,dir) {
  return (Pos(row <- row(pos) + vOffset(dir)
             ,col <- col(pos) + hOffset(dir)
  ))
}

function vOffset (dir) {
  return (matching (dir) select
            -1 on South
             1 on North
             0 otherwise) 
}

function hOffset (dir) {
  return (matching (dir) select
            -1 on West
             1 on South
             0 otherwise) 
}

procedure DrawPos_With_(vec, color) {
  Drop__Times(color, codeOfPos_(vec))
}

function codeOfPos_(vec) {
  /* PRECOND: * col of vec <= 999 */
  return (row(vec)*1000 + col(vec))
}

function currentPosWith_(color) {
  code := numStones(color)
  return (Pos(row <- code div 1000
             ,col <- code mod 1000
  ))
}

// ---------
// Genders 
// ---------
type Gender is variant {
   case Masculine {}
   case Femenine {}
   // case Both {}
   // case None {}
}

procedure DrawGender_With_(gender, color) {
   Drop__Times(color, codeOfGender_(gender))
}

function codeOfGender_(gender) {
  return (matching (gender) select
            1 on Masculine
            2 on Femenine
            boom(msgNotExpected("Gender")) otherwise)
}

function currentGenderWith_(color) {
  /* PRECOND:
       * there is a gender represented (between 1 to 2 color stones)
  */
  return(decodeGender_(numStones(color)))
}

function decodeGender_(code) {
  /* PRECOND:
       * code is the coding of a Gender (between 1 and 2)
  */
  return(matching (code) select
           Masculine  on 1
           Femenine   on 2
           boom(msgNotACodeFor_("Gender")) otherwise)
}

// ---------
// Board traversal operations 
// ---------
procedure StartBoardTraverseTo_And_(mainDir, secDir) {
  GoToCorner__(opposite(mainDir), opposite(secDir))
}

function atEndOfBoardTraverseTo_And_(mainDir, secDir) {
  return(not canMove(mainDir) && not canMove(secDir))
}

procedure GoToNextCellInBoardTraverseTo_And_(mainDir, secDir) {
  /* PRECOND:
     * head is not at end of a board traverse to mainDir and secDir
  */
  if (canMove(mainDir)) { Move(mainDir) }
  else                  { GoToEdge(opposite(mainDir))
                          Move(secDir)
                        }
}

// ---------
// List functions 
// ---------
function elemAtPos_In_(pos,xss) {
  /* PRECOND:
       * there are at least 1+row(pos) elements in xss
       * there are at least 1+col(pos) elements in elemAtIndex_In_(row(pos),xss)
  */
  row := elemAtIndex_In_(row(pos), xss)
  return(elemAtIndex_In_(col(pos), row))
}

function elemAtIndex_In_(idx,xs) { 
  /* PRECOND: * there are at least 1+idx elements in xs */
  return(list_At_(xs,idx)) 
}

function list_At_(xs, idx) {
  /* PRECOND: * there are at least 1+idx elements in xs */
  currentList := xs
  repeat (idx) { currentList := tail(currentList) }
  return (head(currentList))
}

function column_Of_(col, xss) {
  /* PRECOND:
       * all elements.of xss have at least col+1 elements
  */
  columnSeen := [ ]
  foreach row in xss { columnSeen := columnSeen ++ [ elemAtIndex_In_(col, row) ] }
  return (columnSeen)
}

function set_AtPos_To_(xss, pos, x) {
  row    := list_At_(xss, row(pos))
  newRow := set_AtIndex_To_(row, col(pos), x)
  return(set_AtIndex_To_(xss, row(pos), newRow))
}

function set_AtIndex_To_(xs, i, x) {
  /* PRECOND:
       * xs has at least i+1 elements
  */
  let (prev, oldX, post) := split_At_(xs, i)
  return(prev ++ [x] ++ post)
}

function split_At_(xs, i) {
  /* PRECOND: 
       * xs has at least i+1 elements
  */
  seen := [ ]
  toSee := xs
  repeat (i) { 
     seen := seen ++ head(toSee)
     toSee := tail(toSee)
  }
  return(seen, head(toSee), tail(toSee))
}

function reverse(xs) {
  reversed := []
  foreach x in xs {
    reversed := [x]++reversed
  }
  return(reversed)
}

function replicate__Times(x, n) {
  processed := []
  repeat(n) { processed := [x] ++ processed }
  return (processed)
}

function listFrom_To_(low,high) {
  processed := []
  current := low
  repeat (high - low + 1) {
    processed := [current] ++ processed
    current := current + 1
  }
  return (processed)
}

// ---------
// Stacks 
// ---------
type Stack is record {
  field data  // [ Elements ]
}

function emptyS()     { return (Stack(data <- [ ]))             }
function isEmptyS(st) { return(not isEmpty(data(st)))           }
function push(x, st)  { return (Stack(data <- [x] ++ data(st))) }
function top(st)      { return (head(data(st)))                 } /* PRECOND: st is not empty */
function pop(st)      { return (Stack(data <- tail(data(st))))  } /* PRECOND: st is not empty */

// ---------
// ERROR MESSAGES
// ---------
function msgNotACodeFor_(element) {
  return(babel("Not a " ++ element ++" code"
              ,"No es un código para " ++ element)) 
}
/* ============================================================================================================
   END Prelude.gbs
   ============================================================================================================
*/


/* ============================================================================================================
   START QuellRepresentation.gbs
   Definition of the datatypes representing a Quell level
// REQUIRE: Babel.gbs
// REQUIRE: Prelude.gbs
   ============================================================================================================
*/

type QuellLevel is record {
  /* INV.REP.:
       * board represent a Quell level
           - all elements of the list at field board are lists of the same length
           - all rows or columns that have some element diferent of Out have at least 2 Limits pointing to each other (no other limit in between 2 pointing limits), and all elements different from Out in between a pair of pointing limits, and no Out elements are in between a pair of pointing limits
           - if the ball field is Just(fromJust<-pos), then the element at pos in board is either Empty or an open Gate or a Portal or a Switch, and pos is between Limits pointing to each other
           - the inTransit field is Just(dirOfMove) iff ball is not Nothing and the QElem in the next position in the dirOfBoard (see nextPos) is not a blocking element, that is:
               + a Wall, or 
               + a Spike pointing at opposite(dirOfMove), or 
               + a closed Gate
               + a blocked Box
           - all doors of Portals are valid positions in the board
           - every QElem equal to a Portal is placed at one of its doors' position, and in the other position there is also a Portal with matching doors
           - all Switches have the same value in their dir fields
           - all Spikes that have the  rotable field in True, have the same value for their dir field, and it is the same value than the dir field in all Switches
       * numPearls is equal to the number of pearls in the board
       * minMoves is the minimum number of moves required to solve the level using Quell rules (Nothing if not solvable)
       * the pos at field jewel indicates a valid position in the given board, and the QElem in that position is either Wall or Empty
       * the QElem at SouthWest corner of the board is Out (for drawing information about the level)
       * either there is any rotable spikes, at least a Switch, and spikeDir should be different from Nothing, 
             or there is no rotable spikes, no Switches, and spikeDir is Nothing
   */
   field board     // [[QElem]] 
   field ball      // Maybe(Pos)
   field inTransit // Maybe(Dir)
   field numPearls // Number
   field minMoves  // Maybe(Number)
   field spikesDir // Maybe(Direction)
   field jewel     // QJewel
}

type QElem is variant {
   case Empty      {}
   case Pearl      {}
   case Wall       {}
   case Box        { field gender }     // Gender
   case Limit      { field corner       // Maybe((Dir, Dir))
                     field pointsTo     // Maybe(Dir)
                   }
   case Portal     { field doorA        // Pos
                     field doorB        // Pos
                   }
   case Multispike {}
   case Spike      { field notRotable } // Maybe(Dir)
   case Switch     { } 
   case Gate       { field open }       // Bool
   case Out        {}
}

type QJewel is record {
   field jpos         // Pos
   field hitsReceived // Number 
   field found        // Bool
}

type BallAction is variant {
  case Move {}
  case Stay {}
  case Pop  {}
}

// ---------------------------
//  Abbreviations
// ---------------------------
function cNW()     { return(Limit(corner   <- just((East , South)), pointsTo <- Nothing))   }
function cNE()     { return(Limit(corner   <- just((South, West )), pointsTo <- Nothing))   }
function cSE()     { return(Limit(corner   <- just((West , North)), pointsTo <- Nothing))   }
function cSW()     { return(Limit(corner   <- just((North, East )), pointsTo <- Nothing))   }

function cNW_(dir) { return(Limit(corner   <- just((East , South)), pointsTo <- just(dir))) }
function cNE_(dir) { return(Limit(corner   <- just((South, West )), pointsTo <- just(dir))) }
function cSE_(dir) { return(Limit(corner   <- just((West , North)), pointsTo <- just(dir))) }
function cSW_(dir) { return(Limit(corner   <- just((North, East )), pointsTo <- just(dir))) }

function aNW()     { return(Limit(corner   <- just((South, East )), pointsTo <- Nothing))   }
function aNE()     { return(Limit(corner   <- just((West , South)), pointsTo <- Nothing))   }
function aSE()     { return(Limit(corner   <- just((North, West )), pointsTo <- Nothing))   }
function aSW()     { return(Limit(corner   <- just((East , North)), pointsTo <- Nothing))   }

function aNW_(dir) { return(Limit(corner   <- just((South, East )), pointsTo <- just(dir))) }
function aNE_(dir) { return(Limit(corner   <- just((West , South)), pointsTo <- just(dir))) }
function aSE_(dir) { return(Limit(corner   <- just((North, West )), pointsTo <- just(dir))) }
function aSW_(dir) { return(Limit(corner   <- just((East , North)), pointsTo <- just(dir))) }

function lH_(dir)   { return(Limit(corner   <- Nothing    , pointsTo <- just(dir))) }
function lV_(dir)   { return(Limit(corner   <- Nothing    , pointsTo <- just(dir))) }

// ---------------------------
//  Detection functions
// ---------------------------
function isEmpty_(qelem)      { return(matching (qelem) select True  on Empty       False otherwise) }
function isPearl_(qelem)      { return(matching (qelem) select True  on Pearl       False otherwise) }
function isWall_(qelem)       { return(matching (qelem) select True  on Wall        False otherwise) }
function isBox_(qelem)        { return(matching (qelem) select True  on Box         False otherwise) }
function isLimit_(qelem)      { return(matching (qelem) select True  on Limit       False otherwise) }
function isPortal_(qelem)     { return(matching (qelem) select True  on Portal      False otherwise) }
function isMultispike_(qelem) { return(matching (qelem) select True  on Multispike  False otherwise) }
function isSpike_(qelem)      { return(matching (qelem) select True  on Spike       False otherwise) }
function isSwitch_(qelem)     { return(matching (qelem) select True  on Switch      False otherwise) }
function isGate_(qelem)       { return(matching (qelem) select True  on Gate        False otherwise) }
function isOut_(qelem)        { return(matching (qelem) select True  on Out         False otherwise) }

function isRotableSpike(qelem) {
  return(matching (qelem) select 
           isRotable_(qelem) on Spike
           False             otherwise)
}

function isRotable_(qelem) {
  /* PRECOND: qelem is a Spike */
   return(notRotable(qelem)==Nothing)
}

// ---------------------------
//  Ball information
// ---------------------------
function dirOfBallOn_(quell)    { return(inTransit(quell))                           }
function hasQBall_(quell)       { return(not isNothing(ball(quell)))                 }
function hasMovingQBall_(quell) { return(hasQBall_(quell) && ballAt_IsMoving(quell)) }
function ballOn_IsMoving(quell) { return(not isNothing (inTransit(quell)))           }

function ballPosOn_(quell) {
  /* PRECOND: * there is a Ball in quell (ball(quell) is not Nothing) */
  return (fromJust(ball(quell)))
}
/* ============================================================================================================
   END QuellRepresentation.gbs
   ============================================================================================================
*/


/* ============================================================================================================
   START Quell-IO.gbs
   Operations to draw and read a Quell level from the board
// REQUIRE: Babel.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: QuellRepresentation.gbs
   ============================================================================================================
*/

// ---------
// Quell I/O operations
// ---------
function currentQuell() {
  /* PRECOND: * there is a quell level represented in the Gobstones board */
  return (currentQLevel())
}

procedure WriteQuell_(quell) {
  /* PRECOND: * Gobstones board is big enough to represent the quell board */
  DrawQLevel_(quell)
}

// ---------
// Representation
// ---------
/*
  The ball is represented with ballColor() stones (standard representation for MDir:, 1 to 5 stones:
    + moving North, 1 stone
    + moving East,  2 stones
    + moving South, 3 stones
    + moving West,  4 stones
    + not moving,   5 stones)
     
   QElements are represented with qelemColor() stones, and their attributes with attrAColor() and attrBColor() stones, depending of the case.
    + Empty, no qelem stones
    + Pearl,      1 stone
    + Wall,       2 stones
    + Box,        3 stones
    + Limit,      4 stones
                     * isCorner, attrA stones (1-4 for corners, 5-8 for angles)
                     * pointsTo, attrB stones 
    + Portal, 5 stones
                     * doorA,    attrA stones
                     * doorB,    attrB stones
    + Multispike, 6 stones
    + Spike,      7 stones
                     * rotable,  attrA stones 
    + Switch,     8 stones
    + Gate,       9 stones
                     * open,     attrA stones
    + Out,       10 stones (or 110 for special case)
  
   QLevel info is represented at SouthWestWest corner with 110 qelem stones and 
    + attrA stones to indicate minMoves of the level
    + attrB stones to indicate if jewel was found
    + the field spikesDir is indicated with attrA stones at all Switches, if it is different from Nothing

  The jewel is represented on its position if it was not found, using
    + hitsReceived, attrA stones
*/

// ---------
// Reading operations
// OBS: All operations has as PRECOND:
//        * there is a quell level represented in the Gobstones board 
// ---------
function currentQLevel() {
  let (curMinMoves, found)                   := currentQInfo()
  let (curBoard, curNumPearls, curSpikesDir) := currentQBoard()
  let (curBallMPos, curBoardMDir)            := currentQBallInfo()
  curJewelInfo                               := currentQJewel(found)
  return (QuellLevel(board     <- curBoard
                   , ball      <- curBallMPos
                   , inTransit <- curBoardMDir
                   , numPearls <- curNumPearls
                   , minMoves  <- curMinMoves
                   , spikesDir <- curSpikesDir
                   , jewel     <- curJewelInfo))
}

// Level 1
function currentQInfo() {
  GoToCorner__(South, West)
  Assert_OrFail_(numStones(qelemColor()) == 110, msgNoQuellLevel())
  curMinMoves := currentMNumWith_(attrAColor())
  found       := currentBoolWith_(attrBColor())
  return (curMinMoves, found)
}

function currentQBoard() {
  GoToCorner__(South,East)
  let (curBoard, curNumPearls, curSpikesDir) := currentRowInfo()
  while (canMove(North)) {
    Move(North)
    let (rows, numPearls, newSpikesDir) := currentRowInfo()
    curSpikesDir := firstOf_Or_(curSpikesDir, newSpikesDir)
    curBoard     := rows ++ curBoard
    curNumPearls := curNumPearls + numPearls
  } 
  return(curBoard, curNumPearls, curSpikesDir)
}

function currentQBallInfo() {
  GoToBall()
  return(choose (just(currentPos()), currentMDirWith_(ballColor())) when (hasBall())
                (Nothing           , Nothing)                       otherwise)
}

function currentQJewel(found) {
  /* PRECOND: * there is a jewel represented in the board */
  GoToQJewel()
  return(QJewel(found        <- found
              , jpos          <- currentPos()
              , hitsReceived <- numStones(attrAColor())-1))
}

// Level 2
procedure GoToBall() {
  StartBoardTraverseTo_And_(East, North)
  while(not atEndOfBoardTraverseTo_And_(East, North) 
     && not hasBall()) {
    GoToNextCellInBoardTraverseTo_And_(East, North) 
  }
}

procedure GoToQJewel() {
  StartBoardTraverseTo_And_(East, North)
  while(not atEndOfBoardTraverseTo_And_(East, North) 
     && not hasQJewel()) {
    GoToNextCellInBoardTraverseTo_And_(East, North) 
  }
}

function currentRowInfo() {
  GoToEdge(West)
  let (qelem, curSpikesDir) := currentQElem()
  curRow       := [ qelem ]
  curNumPearls := delta(isPearl_(qelem))
  while (canMove(East)) {
     Move(East)
     let (qelem, newSpikesDir) := currentQElem()
     curSpikesDir := firstOf_Or_(curSpikesDir, newSpikesDir)
     curRow       := [ qelem ] ++ curRow
     curNumPearls := curNumPearls + delta(isPearl_(qelem))
  }
  return ([ curRow ], curNumPearls, curSpikesDir)
}

function currentQElem() {
  /* PRECOND: * there is a qelem represented in the current cell */
  
  return(matching (numStones(qelemColor())) select
          Empty                 on 0
          Pearl                 on 1
          Wall                  on 2
          currentBox()          on 3
          currentLimit()        on 4
          currentPortal()       on 5
          Multispike            on 6
          currentSpike()        on 7
          currentSwitch()       on 8
          currentGate()         on 9
          Out                   on 10
          Out                   on 110
          boom(msgNoQElement()) otherwise 
      , choose currentMDirWith_(attrAColor()) when (numStones(qelemColor()) == 7) 
               Nothing                        otherwise)
}

function currentBox() {
  /* PRECOND: * there is a box represented in the current cell */
  return(Box(gender <- currentGenderWith_(attrAColor())))
}

function currentLimit() {
  /* PRECOND: * there is a limit represented in the current cell */
  return(Limit(corner   <- currentCornerWith_(attrAColor())
             , pointsTo <- currentMDirWith_(attrBColor())))
}

function currentPortal() {
  /* PRECOND: * there is a portal represented in the current cell */
  return(Portal(doorA <- currentPosWith_(attrAColor())
              , doorB <- currentPosWith_(attrBColor())))
}

function currentSpike() {
  /* PRECOND: * there is a spike represented in the current cell */
  return(Spike(notRotable <- currentMDirWith_(attrAColor())))
}

function currentSwitch() {
  /* PRECOND: * there is a switch represented in the current cell */
  return(Switch)
}

function currentGate() {
  /* PRECOND: * there is a gate represented in the current cell */
  return(Gate(open <- currentBoolWith_(attrAColor())))
}

function currentCornerWith_(color) { 
  code := numStones(color)
  return(choose Nothing             when (code==9)
                decodedDir_(code-4) when (num_IsBetween_And_(code, 5, 8))
                decodedDir_(code)   otherwise)
}

function hasBall()   { return(num_IsBetween_And_(numStones(ballColor()), 1, 5))     }
function hasQJewel() { return((hasWall() || hasEmpty()) && hasStones(attrAColor())) }
function hasWall()   { return(numStones(qelemColor())==2)                           }
function hasEmpty()  { return(numStones(qelemColor())==0)                           }

// ---------
// Drawing operations
// ---------
procedure DrawQLevel_(quell) {
  ClearBoard()
  DrawQInfo_(quell)
  DrawQBoard_WithSpikesTo_(board(quell), spikesDir(quell))
  DrawQJewel_(jewel(quell))
  DrawQBall_To_(ball(quell), inTransit(quell))
}

// Level 1
procedure DrawQInfo_(quell) {
  GoToCorner__(South, West)
  Drop__Times(qelemColor(), 100)
  DrawMNum_With_(minMoves(quell), attrAColor())
  DrawBool_With_(found(jewel(quell)), attrBColor())
}

procedure DrawQBoard_WithSpikesTo_(board, spikesDir) {
  /* PRECOND: * the board has at least one qelem */
  GoToCorner__(South, West)
  curBoard := reverse(board)
  DrawQRow_WithSpikesTo_(head(curBoard), spikesDir)
  foreach row in tail(curBoard) {
    Move(North)
    DrawQRow_WithSpikesTo_(row, spikesDir)
  }
}

procedure DrawQBall_To_(ball, mdir) {
   if (not isNothing(ball)) {
     pos := fromJust(ball)
     GoToCell_(pos)
     DrawBall_(mdir)
   }
}

procedure DrawQJewel_(jewel) {
  GoToCell_(jpos(jewel))
  Drop__Times(attrAColor(), 1+hitsReceived(jewel))
  DrawBool_With_(found(jewel), attrBColor())
}

// Level 2
procedure DrawBall_(mdir) {
  DrawMDir_With_(mdir, ballColor())
}

procedure DrawQRow_WithSpikesTo_(row, spikesDir) {
  /* PRECOND: * the row has at least one element */
  GoToEdge(West)
  DrawQelem_WithSpikesTo_(head(row), spikesDir)
  foreach qelem in tail(row) {
    Move(East)
    DrawQelem_WithSpikesTo_(qelem, spikesDir)  
  }
}

procedure DrawQelem_WithSpikesTo_(qelem, spikesDir) {
  Drop__Times(qelemColor(), codeOfQelem_(qelem))
  switch (qelem) to {
    Box(gender)             -> { DrawGender_With_(gender   , attrAColor()) }
    Limit(corner, pointsTo) -> { DrawCorner_With_(corner   , attrAColor())
                                 DrawMDir_With_  (pointsTo , attrBColor()) }
    Portal(doorA, doorB)    -> { DrawPos_With_   (doorA    , attrAColor())
                                 DrawPos_With_   (doorB    , attrBColor()) }
    Spike(rotable)          -> { DrawMDir_With_  (rotable  , attrAColor()) }
    Switch()                -> { DrawMDir_With_  (spikesDir, attrAColor()) }
    Gate(open)              -> { DrawBool_With_  (open     , attrAColor()) }
    _                       -> { }
    }
}

procedure DrawCorner_With_(corner, color) {
  switch (corner) to {
    Nothing    -> { Drop__Times(color, 9) }
    Just(d1d2) -> { d1 := fst(d1d2)
                    d2 := snd(d1d2)
                    if     (d2==nextDir(d1)) { DrawDir_With_(d1,color)              }
                    elseif (d2==prevDir(d1)) { Drop__Times(color, 4+codeOfDir_(d1)) }
                    else                     { BOOM(msgInvalidQuell())              }
                  }
  }
}

// ---------
// Codes
// ---------
function codeOfQelem_(qelem) {
  return (matching (qelem) select
             0 on Empty
             1 on Pearl
             2 on Wall
             3 on Box
             4 on Limit
             5 on Portal
             6 on Multispike
             7 on Spike
             8 on Switch
             9 on Gate
            10 on Out
            boom(msgNotExpected("QElem")) otherwise
  )
}

// ---------
// Colors
// ---------
function ballColor()  { return(Blue)  }
function qelemColor() { return(Black) }
function attrAColor() { return(Red)   }
function attrBColor() { return(Green) }

// ---------
// Error messages
// ---------
function msgNoQuellLevel() { 
  return(babel("There is no Quell level represented on the board"
              ,"No hay un nivel de Quell representado en el tablero"))
}

function msgNoQElement() { 
  return(babel("There is no QElement represented in the current cell"
              ,"No hay un QElement representado en la celda actual"))
}

function msgInvalidQuell() { 
  return(babel("Quell representation is invalid"
              ,"La representación de Quell es inválida"))
}

/* ============================================================================================================
   END Quell-IO.gbs
   ============================================================================================================
*/
