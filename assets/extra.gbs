/* ============================================================================================================
   START Babel.gbs
   Code for swap between  errors messages on different languages
   ============================================================================================================
*/
function language() { return(English) }

procedure Assert_OrFail_(condition, msg) { if (not condition) { BOOM(msg) } }
procedure ClearBoard()  { VaciarTablero() }

// ---------
// Internationalization
// ---------
type Language is variant {
  case English {}
  case Spanish {}
}

function babel(msgEn, msgSp) { 
  return(matching (language()) select 
           msgSp on Spanish
           msgEn otherwise)
}
/* ============================================================================================================
   END Babel.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START EnglishPrimitives.gbs
   Code for using English names on Gobstones programs, even when the language is still not internationalized
// REQUIRE: Babel.gbs
   ============================================================================================================
*/
// ---------
// Colors
// ---------
type Colour is variant {
    case Red    {}
    case Green  {}
    case Blue   {}
    case Black  {}
}

function colorEn2Sp(color) {
  return(matching (color) select
           Rojo   on Red
           Verde  on Green
           Azul   on Blue
           Negro  on Black
           boom(msgNotExpected("Colour")) otherwise)
}

function colorSp2En(color) {
  return(matching (color) select
           Red   on Rojo    
           Green on Verde   
           Blue  on Azul   
           Black on Negro
           boom(msgNotExpected("Color")) otherwise)
}

function hasStones(color) { return(hayBolitas(colorEn2Sp(color))) }
function numStones(color) { return(nroBolitas(colorEn2Sp(color))) }

procedure Drop(color) { Poner(colorEn2Sp(color)) }
procedure Grab(color) { 
    Assert_OrFail_(hasStones(color), msgNoStones())
    Sacar(colorEn2Sp(color)) 
}

function nextColor(color)  { return(colorSp2En(siguiente(colorEn2Sp(dir)))) }
function prevColor(color)  { return(colorSp2En(previo(colorEn2Sp(dir))))    }

function minColour() { return(colorSp2En(minColor())) }
function maxColour() { return(colorSp2En(maxColor())) }

// ---------
// Directions
// ---------
type Direction is variant {
    case North {}
    case East  {}
    case South {}
    case West  {}
}

function dirEn2Sp(dir) {
  return(matching (dir) select
           Norte on North
           Este  on East
           Sur   on South
           Oeste on West
           boom(msgNotExpected("Direction")) otherwise)
}

function dirSp2En(dir) {
  return(matching (dir) select
           North on Norte
           East  on Este 
           South on Sur  
           West  on Oeste
           boom(msgNotExpected("Dirección")) otherwise)
}

function canMove(dir) { return(puedeMover(dirEn2Sp(dir))) }

procedure Move(dir) { 
  Assert_OrFail_(canMove(dir), msgNoCells())
  Mover(dirEn2Sp(dir))     
}

procedure GoToEdge(dir) { IrAlBorde(dirEn2Sp(dir)) }

function opposite(dir) { return(dirSp2En(opuesto(dirEn2Sp(dir))))   }
function nextDir(dir)  { return(dirSp2En(siguiente(dirEn2Sp(dir)))) }
function prevDir(dir)  { return(dirSp2En(previo(dirEn2Sp(dir))))    }

function minDirection() { return(dirSp2En(minDir())) }
function maxDirection() { return(dirSp2En(maxDir())) }

// ---------
// Lists
// ---------
function isEmpty(xs) { return(esVacía(xs)) }
function head(xs)    { return(primero(xs)) }
function tail(xs)    { return(resto(xs))   }

// ---------
// ERROR MESSAGES
// ---------
function msgNoStones() { 
  return(babel("Cannot grab stones: there are no stones of that color"
              ,"No puedo sacar bolitas: no hay bolitas de ese color"
              ))
}

function msgNoCells() { 
  return(babel("Cannot move: there are no cells on that direction"
              ,"No puedo mover hacia ahí: no hay celdas en esa dirección"
              ))
}

function msgNotExpected(element) { 
  return(babel("CANNOT HAPPEN: has some element changed?"
              ,"NO PUEDE SUCEDER: ¿cambió algún elemento?"
              ))
}
/* ============================================================================================================
   END EnglishPrimitives.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Prelude.gbs
   General useful operations for a number of conveniencies
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
   ============================================================================================================
*/

// ---------
// Gobstones auxiliary functions
// ---------
procedure GoToCorner__(dir1, dir2) { /* PRECOND: dir1 and dir2 are not equal and not opposite of each other */                                            
  GoToEdge(dir1)
  GoToEdge(dir2)
}

procedure Drop__Times(color, num) { repeat (num) { Drop(color) } }
procedure Grab__Times(color, num) { repeat (num) { Grab(color) } }
procedure Move__Times(dir, num)   { repeat (num) { Move(dir)   } }

procedure GrabAll(color) { Grab__Times(color, numStones(color)) }
procedure ClearCell() { foreach color in [minColour()..maxColour()] { GrabAll(color) } }

function isHorizontal(dir) { return (dir==East  || dir==West)  }
function isVertical(dir)   { return (dir==North || dir==South) }

function adjust_To_(val, max)             { return ((val+max) mod max) }
function num_IsBetween_And_(n, low, high) { return(n>=low && n<=high)  }

function delta(b) { return (choose 1 when (b) 0 otherwise) }

// ---------
// Math functions 
// ---------
function timesOf_In_(p,n) { 
  currentN     := n
  currentTimes := 0
  while (currentN>=p) {
    currentTimes := currentTimes + 1
    currentN     := currentN-p
  }
  return (currentTimes)
}

function maxPowerOf_LessThan_(n, m) {
   currentPow := 1
   while (currentPow <= m) {
      currentPow := currentPow * n
   }
   return (currentPow div n)
}

function maxPowerOf_WithAccumPowLessThan_(n, p) {
   currentPow := 1
   currentSum := currentPow
   while (currentSum <= p) {
        currentPow := currentPow * n
        currentSum := currentPow + currentSum
    }
   return (currentPow div n)
}

// ---------
// Coding functions 
// ---------

// Dir
procedure DrawDir_With_(dir, color) { Drop__Times(color, codeOfDir_(dir))   }
function  currentDirWith_(color)    { return(decodedDir_(numStones(color))) } /* PRECOND: * there is a Dir represented (between 1 to 4 color stones) */

function codeOfDir_(dir) {
  return (matching (dir) select
            1 on North
            2 on East
            3 on South
            4 on West
            boom(msgNotExpected("Direction")) otherwise)
}

function decodedDir_(code) { /* PRECOND: code is the coding of a Dir (between 1 and 4) */
  return(matching (code) select
           North on 1
           East  on 2
           South on 3
           West  on 4
           boom(msgNotACodeFor_("Direction")) otherwise)
}

// Num
procedure DrawNum_With_(n, color) { Drop__Times(color, n)    }
function  currentNumWith_(color)  { return(numStones(color)) }

// Bool
procedure DrawBool_With_(b, color) { Drop__Times(color, codeOfBool_(b))     }
function  currentBoolWith_(color)  { return(decodedBool_(numStones(color))) } /* PRECOND: there is a bool represented in the current cell with the given color */

function codeOfBool_(b) {
  return (choose 1 when (b)
                 0 otherwise)
}

function decodedBool_(code) { /* PRECOND: code is the coding of a Bool (either 0 or 1) */
  return(matching (code) select
           True   on 1
           False  on 0
           boom(msgNotACodeFor_("Bool")) otherwise)
}

// [Dir]
function codeOfDirs_(dirs) {
  /* OBS: the coding is a 0-less one */
  currentCode := 0
  currentPow  := 1
  foreach dir in dirs {
    currentCode := currentCode + currentPow * codeOfDir_(dir)
    currentPow  := currentPow * 4
  }
  return (currentCode)
}
                
function decodedDirs_(code) {
   /* OBS: for decoding, 0-s need to be adjusted */
   curCodes   := []
   currentPow := maxPowerOf_WithAccumPowLessThan_(4, code)
   remCode    := code
   while (currentPow > 0) {                   // (code-remCode) is encoded in curCodes (shifted by currentPow)
     curCode    := timesOf_In_(currentPow, remCode)
     if (curCode == 0) {                      // As a code digit cannot be 0, 1 must be substracted of previous calculus
         curCodes := substractOneFromDirCodes_(curCodes)
         remCode  := remCode + currentPow * 4 // remCode needs adjustment too, to keep the invariant
         curCode  := 4
     }
     remCode    := remCode - (curCode * currentPow)
     currentPow := currentPow div 4
     curCodes      := [ curCode ] ++ curCodes
   }
   return(mapDecodeDirsTo_(curCodes))
}

function mapDecodeDirsTo_(codes) {
  currentRes := []
  foreach code in codes {
    currentRes := currentRes ++ [ decodedDir_(code) ]
  }
  return (currentRes)
}

function substractOneFromDirCodes_(codes) {
  /* PURPOSE: substracts one in a 0-less representation in base 4
     PRECOND: codes is not []  
  */
  curCode  := head(codes)
  curCodes := tail(codes)
  curSeen := []
  while (curCode==1 && not isEmpty(curCodes)) {
        curSeen  := curSeen ++ [4]
        curCode  := head(curCodes)
        curCodes := tail(curCodes)
  }
  if (curCode>1) { curSeen := curSeen++[curCode-1] }
  return (curSeen++curCodes)
}

// ---------
// Pairs
// ---------
function fst(pair) {
    return(matching (pair) select 
               x on (x,y)
               boom(msgNotExpected("pair (A,B)")) otherwise)
}

function snd(pair) {
    return(matching (pair) select 
               y on (x,y)
               boom(msgNotExpected("pair (A,B)")) otherwise)
}

// ---------
// Maybe 
// ---------
type Maybe is variant {
  case Nothing  {}
  case Just     { field fromJust }  
}

function isNothing(mv) { return(matching (mv) select True on Nothing False otherwise) }
function just(elem)    { return (Just(fromJust <- elem)) }

function firstOf_Or_(md1, md2) {
 return(matching (md1) select
          md1 on Just
          md2 otherwise)
}

procedure DrawMNum_With_(mNum, color) {
  Drop__Times(color, matching (mNum) select
                       1 + fromJust(mNum) on Just
                       0                  otherwise)
}

function currentMNumWith_(color) {
  return (choose
            Nothing                   when (numStones(color) == 0)
            just(numStones(color)-1)  otherwise)
}

procedure DrawMDir_With_(mdir, color) { Drop__Times(color, codeOfMDir_(mdir)) }
function codeOfMDir_(mdir) {
  return (matching (mdir) select codeOfDir_(fromJust(mdir)) on Just
                                 0                          otherwise)
}

function currentMDirWith_(color) { /* PRECOND: there is a MDir represented (between 1 to 5 color stones) */
  return(choose just(currentDirWith_(color)) when (hasStones(color))
                Nothing                      otherwise)
}

// ---------
// Pos
// ---------
type Pos is record {
   field row    // Number
   field col    // Number
}

function pos(c, r) { return(Pos(row <- r, col <- c)) }

procedure GoToCell_(pos) {
  GoToEdge(West)      
  Move__Times(East, col(pos))   
  GoToEdge(South)  
  Move__Times(North, row(pos))    
}

function currentPos() {
  return(Pos(row <- rowIndex()
            ,col <- colIndex()))
}

function rowIndex() { return(distanceToEdge_(South)) }
function colIndex() { return(distanceToEdge_(West))  }

function distanceToEdge_(dir) {
  measured := 0
  while (canMove(dir)) { Move(dir); measured := measured+1 }
  return (measured)
}

function nextPosOf_To_(pos,dir) {
  return (Pos(row <- row(pos) + vOffset(dir)
             ,col <- col(pos) + hOffset(dir)
  ))
}

function vOffset (dir) {
  return (matching (dir) select
            -1 on South
             1 on North
             0 otherwise) 
}

function hOffset (dir) {
  return (matching (dir) select
            -1 on West
             1 on East
             0 otherwise) 
}

procedure DrawPos_With_(vec, color) { Drop__Times(color, codeOfPos_(vec)) }

function currentPosWith_(color) {
  code := numStones(color)
  return (Pos(row <- code div 1000
             ,col <- code mod 1000
  ))
}

function codeOfPos_(vec) {
  /* PRECOND: col of vec <= 99 */
  return (row(vec)*100 + col(vec))
}

// ---------
// Genders 
// ---------
type Gender is variant {
   case Masculine {}
   case Femenine {}
   // case Both {}
   // case None {}
}

procedure DrawGender_With_(gender, color) { Drop__Times(color, codeOfGender_(gender)) }
function  currentGenderWith_(color)       { return(decodeGender_(numStones(color)))   } /* PRECOND: there is a gender represented (between 1 to 2 color stones) */

function codeOfGender_(gender) {
  return (matching (gender) select
            1 on Masculine
            2 on Femenine
            boom(msgNotExpected("Gender")) otherwise)
}

function decodeGender_(code) { /* PRECOND: code is the coding of a Gender (between 1 and 2) */
  return(matching (code) select
           Masculine  on 1
           Femenine   on 2
           boom(msgNotACodeFor_("Gender")) otherwise)
}

// ---------
// Board traversal operations 
// ---------
procedure StartBoardTraverseTo_And_(mainDir, secDir)   { GoToCorner__(opposite(mainDir), opposite(secDir))   }
function  atEndOfBoardTraverseTo_And_(mainDir, secDir) { return(not canMove(mainDir) && not canMove(secDir)) }
procedure GoToNextCellInBoardTraverseTo_And_(mainDir, secDir) { /* PRECOND: head is not at end of a board traverse to mainDir and secDir */
  if (canMove(mainDir)) { Move(mainDir) }
  else                  { GoToEdge(opposite(mainDir))
                          Move(secDir)
                        }
}

// ---------
// List functions 
// ---------
function lengthOf_(xs) {
  counted := 0
  foreach elem in xs { counted := counted+1 }
  return (counted)
}

function elem_IsIn_(x, xs) {
  current := xs
  while (not isEmpty(current) && x/=head(current)) {
    current := tail(current)
  }
  return (not isEmpty(current))
}

function elemAtPos_In_(pos,xss) {
  /* PRECOND:
       * there are at least 1+row(pos) elements in xss
       * there are at least 1+col(pos) elements in elemAtIndex_In_(row(pos),xss)
  */
  row := elemAtIndex_In_(row(pos), xss)
  return(elemAtIndex_In_(col(pos), row))
}

function elemAtIndex_In_(idx,xs) { return(list_At_(xs,idx)) } /* PRECOND: there are at least 1+idx elements in xs */

function list_At_(xs, idx) { /* PRECOND: there are at least 1+idx elements in xs */
  currentList := xs
  repeat (idx) { currentList := tail(currentList) }
  return (head(currentList))
}

function column_Of_(col, xss) { /* PRECOND: all elements of xss have at least col+1 elements */
  columnSeen := [ ]
  foreach row in xss { columnSeen := columnSeen ++ [ elemAtIndex_In_(col, row) ] }
  return (columnSeen)
}

function set_AtPos_To_(xss, pos, x) { /* PRECOND: xss has an element at pos */
  row    := list_At_(xss, row(pos))
  newRow := set_AtIndex_To_(row, col(pos), x)
  return(set_AtIndex_To_(xss, row(pos), newRow))
}

function set_AtIndex_To_(xs, i, x) { /* PRECOND: xs has at least i+1 elements */
  let (prev, oldX, post) := split_At_(xs, i)
  return(prev ++ [x] ++ post)
}

function split_At_(xs, i) { /* PRECOND: xs has at least i+1 elements */
  seen  := [ ]
  toSee := xs
  repeat (i) { 
     seen  := seen ++ [ head(toSee) ]
     toSee := tail(toSee)
  }
  return(seen, head(toSee), tail(toSee))
}

function reverse(xs) {
  reversed := []
  foreach x in xs {
    reversed := [x]++reversed
  }
  return(reversed)
}

function replicate__Times(x, n) {
  processed := []
  repeat(n) { processed := [x] ++ processed }
  return (processed)
}

function listFrom_To_(low,high) {
  processed := []
  current   := low
  repeat (high - low + 1) {
    processed := [current] ++ processed
    current   := current + 1
  }
  return (processed)
}

// ---------
// Stacks 
// ---------
type Stack is record {
  field data  // [ Elements ]
}

function emptyS()     { return(Stack(data <- [ ]))             }
function isEmptyS(st) { return(not isEmpty(data(st)))          }
function push(x, st)  { return(Stack(data <- [x] ++ data(st))) }
function top(st)      { return(head(data(st)))                 } /* PRECOND: st is not empty */
function pop(st)      { return(Stack(data <- tail(data(st))))  } /* PRECOND: st is not empty */

// ---------
// ERROR MESSAGES
// ---------
function msgNotACodeFor_(element) {
  return(babel("Not a code"
              ,"No es un código")) 
}
/* ============================================================================================================
   END Prelude.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Drawing.gbs
   Operations to draw a Quell level on the board
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
// REQUIRE: Quell-Representation.gbs
   ============================================================================================================
*/

procedure DrawQLevel_(quell) {
  /* OBS: to be used only on the initial drawing */
  ClearBoard()
  DrawTopBar_(quell)
  DrawQBoard_WithSpikesTo_(board(quell), spikesDir(quell))
  DrawQJewel_(jewel(quell))
  DrawQBoxes_(boxes(quell))
  DrawQBall_WithHint_(ball(quell), choose just(head(solution(quell))) when (isTutorial(quell))
                                          Nothing otherwise)
}

// ---------
// Drawing operations
// Level 1
// ---------
procedure DrawTopBar_(quell) {
  GoToCorner__(North,West); MarkTopCell_(0)
  Move(East)              ; EncodeTopNum_As_         (numMoves(quell)                       , 1)
  Move(East)              ; EncodeTopNum_As_         (minMoves(quell)                       , 2)
  GoToEdge(East)          ; EncodeTopMDir_As_        (spikesDir(quell)                      , 0)
  Move(West)              ; EncodeTopNum_AndMNum_As_ (numPearls(quell), numRightMoves(quell), 4)
  Move(West)              ; EncodeTopJewel_As_       (jewel(quell)                          , 3)  
  Move(West)              ; PadEmptyCellAs_(0)
}

procedure DrawQBoard_WithSpikesTo_(board, spikesDir) { 
  /* PRECOND: the board has at least one qelem */
  GoToCorner__(North, West) Move(South)
  DrawQRow_WithSpikesTo_(head(board), spikesDir)
  foreach row in tail(board) { Move(South); DrawQRow_WithSpikesTo_(row, spikesDir) }
}

procedure DrawQJewel_(jewel) { if (isJewel_(jewel)) { GoToCell_(jpos(jewel)); DrawNum_With_(hits(jewel), attrAColor()) } }
procedure DrawQBoxes_(boxes) { foreach box in boxes { GoToCell_(fst(box))   ; DrawGender_With_(snd(box), attrBColor()) } }
procedure DrawQBall_WithHint_(ball, mdir)   { 
  switch (ball) to {
    QBallAt(pos)               -> { GoToCell_(pos); DrawMDir_With_(mdir, ballColor())
                                    Drop__Times(ballColor(), 5)                       }
    QBallTo(pos, dir, beaming) -> { GoToCell_(pos); DrawDir_With_(dir, ballColor())
                                    if (beaming) { Drop__Times(ballColor(), 10) }     }
    NoBall                     -> { }
  }
}

// ---------
// Drawing operations
// Level 2
// ---------
// Top bar operations
procedure MarkTopCell_(i)    { Drop__Times(qelemColor(), 100+i)                            }
procedure PadEmptyCellAs_(i) { while(not isCellAtTopRow()) { MarkTopCell_(i); Move(West) } }
function  isCellAtTopRow()   { return(numStones(qelemColor()) >= 100)                      }

procedure EncodeTopJewel_As_(jewel, i) {
  MarkTopCell_(i)
  DrawBool_With_(isJewel_(jewel), attrAColor())
  DrawBool_With_(False          , attrBColor()) // At the beginning the Jewel is not found
}

procedure EncodeTopBool_As_(b , i) { MarkTopCell_(i); DrawBool_With_(b , attrBColor()) }
procedure EncodeTopPos_As_(pos, i) { MarkTopCell_(i); DrawPos_With_(pos, attrAColor()) }
procedure EncodeTopMDir_As_(md, i) { MarkTopCell_(i); DrawMDir_With_(md, attrAColor()) }
procedure EncodeTopNum_As_(n  , i) { MarkTopCell_(i); DrawNum_With_(n  , attrAColor()) }
procedure EncodeTopNum_AndMNum_As_(n, mn, i) { 
  MarkTopCell_(i) 
  DrawNum_With_ (n, attrAColor()) 
  DrawMNum_With_(mn, attrBColor()) 
}

// Board
procedure DrawQRow_WithSpikesTo_(row, spikesDir) {
  /* PRECOND: the row has at least one element */
  GoToEdge(West)
  DrawQElem_WithSpikesTo_(head(row), spikesDir)
  foreach qelem in tail(row) { Move(East); DrawQElem_WithSpikesTo_(qelem, spikesDir) }
}

procedure DrawQElemId_(qelem) { Drop__Times(qelemColor(), codeOfQelem_(qelem)) }
procedure DrawQElem_WithSpikesTo_(qelem, spikesDir) {
  DrawQElemId_(qelem)
  switch (qelem) to {
    Pearl              -> { DrawBool_With_(True               , attrBColor())            }
    Corner(dir)        -> { DrawDir_With_ (dir                , attrAColor())            }
    Angle(dir)         -> { DrawDir_With_ (dir                , attrAColor())            }
    Limit(pointsTo)    -> { DrawDir_With_ (pointsTo           , attrAColor())            }
    Portal(id, target) -> { DrawPos_With_ (target             , attrAColor())            
                            DrawNum_With_ (id                 , attrBColor())            }
    Gate(closed)       -> { DrawBool_With_(closed             , attrBColor()) }
    Spike(dir)         -> { DrawDir_With_(dir                 , attrAColor())            }
    RotableSpike       -> { Assert_OrFail_(not isNothing(spikesDir), msgInvalidQuell()) // spikesDir cannot be Nothing if there are RotableSpikes
                            DrawDir_With_(fromJust(spikesDir) , attrAColor())            } 
    Switch             -> { Assert_OrFail_(not isNothing(spikesDir), msgInvalidQuell()) // spikesDir cannot be Nothing if there are Switches
                            DrawDir_With_(fromJust(spikesDir) , attrAColor())            } 
    _                  -> { }
    }
}

// ---------
// Error messages
// ---------
function msgInvalidQuell() { 
  return(babel("Quell representation is invalid"
              ,"La representación de Quell es inválida"))
}

/* ============================================================================================================
   END Quell-Drawing.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Model.gbs
   Definition of the datatypes representing a Quell level
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
   ============================================================================================================
*/

type QuellLevel is record {
  /* INV.REP.:
   * board represent the Quell game-board
     - all elements of the game-board are lists of the same length
     - limits (Limits, Angles, and Corners) form a continuous "line"
     - all rows or columns that have some element different from Out or a limit have at least a two paired limits (Limits or Angles pointing to each other) 
     - all elements different from Out or limits are between paired limits
     - no Out or limit elements are between paired limits
     - for each Portal on the board, its target is a valid pos with the only other Portal with matching id on the board
   * solution is a list of Dirs of length minMoves that solves the level
   * minMoves is the minimum number of moves required to solve the level using Quell rules (0 if not solvable)
   * if the jewel field jpos exists, then it indicates a valid position in the board, and the QElem in that position is either Wall or Empty
   * either there is some RotableSpikes, at least a Switch, and spikesDir is different from Nothing, 
     or there is no RotableSpikes, no Switches, and spikesDir is Nothing
   * all pos values in boxes are valid positions in the board, and the QElement in that position is Empty
   * if the ball field bpos exists, then it indicates a valid position in the board, and the QElem in that position is either Empty, or an open Gate, or a Portal, or a Switch
   * if numRightMoves is not Notingh, the number is positive and less than minMoves
   */
   field isTutorial    // Bool
   field board         // [[QElem]] 
   field solution      // [Dir]
   field minMoves      // Number
   field jewel         // QJewel
   field spikesDir     // Maybe(Direction)
   field boxes         // [(Pos, Gender)]
   field ball          // QBall
   field numMoves      // Number
   field numRightMoves // Maybe(Number)
   field numPearls     // Number
}

type QElem is variant {
   case Empty        {}
   case Pearl        {}
   case Wall         {}
   case Corner       { field dir }        // Dir
   case Angle        { field dir }        // Dir
   case Limit        { field pointsTo }   // Dir
   case Portal       { field id           // Number (less than 10)
                       field target       // Pos
                     }
   case Gate         { field closed }     // Bool
   case Spike        { field pointsTo }   // Dir
   case Multispike   {}
   case RotableSpike {}
   case Switch       {} 
   case Out          {}
}

type QJewel is variant {
   case NoJewel {}
   case QJewel  { field jpos // Pos
                  field hits // Number (usually 4 if Wall, and 1 if visible)
                }
}

type QBall is variant {
   case NoBall  {}
   case QBallAt { field bpos }  // Pos
   case QBallTo { field bpos    // Pos
                  field goingTo // Dir 
                  field beaming // Bool
                }
}

// ---------------------------
//  Abbreviations
// ---------------------------
function cNW() { return(Corner(dir <- East))      }
function cNE() { return(Corner(dir <- South))     }
function cSE() { return(Corner(dir <- West))      }
function cSW() { return(Corner(dir <- North))     }
   
function aNW() { return(Angle(dir <- East))       }
function aNE() { return(Angle(dir <- South))      }
function aSE() { return(Angle(dir <- West))       }
function aSW() { return(Angle(dir <- North))      }

function hT()  { return(Limit(pointsTo <- South)) }
function hB()  { return(Limit(pointsTo <- North)) }
function vL()  { return(Limit(pointsTo <- East))  }
function vR()  { return(Limit(pointsTo <- West))  }

// ---------------------------
//  Detection functions
// ---------------------------
function isEmpty_(qelem)        { return(matching (qelem) select True  on Empty        False otherwise) }
function isPearl_(qelem)        { return(matching (qelem) select True  on Pearl        False otherwise) }
function isWall_(qelem)         { return(matching (qelem) select True  on Wall         False otherwise) }
function isCorner_(qelem)       { return(matching (qelem) select True  on Corner       False otherwise) }
function isAngle_(qelem)        { return(matching (qelem) select True  on Angle        False otherwise) }
function isLimit_(qelem)        { return(matching (qelem) select True  on Limit        False otherwise) }
function isPortal_(qelem)       { return(matching (qelem) select True  on Portal       False otherwise) }
function isGate_(qelem)         { return(matching (qelem) select True  on Gate         False otherwise) }
function isSpike_(qelem)        { return(matching (qelem) select True  on Spike        False otherwise) }
function isMultispike_(qelem)   { return(matching (qelem) select True  on Multispike   False otherwise) }
function isRotableSpike_(qelem) { return(matching (qelem) select True  on RotableSpike False otherwise) }
function isSwitch_(qelem)       { return(matching (qelem) select True  on Switch       False otherwise) }
function isOut_(qelem)          { return(matching (qelem) select True  on Out          False otherwise) }

function isNoJewel_(jewel)      { return(matching (jewel) select True  on NoJewel      False otherwise) }
function isJewel_(jewel)        { return(matching (jewel) select True  on QJewel       False otherwise) }

function isNoBall_(qball)       { return(matching (qball) select True  on NoBall       False otherwise) }
function isBall_(qball)         { return(matching (qball) select False on NoBall       True  otherwise) }
function isStaticBall_(qball)   { return(matching (qball) select True  on QBallAt      False otherwise) }
function isMovingBall_(qball)   { return(matching (qball) select True  on QBallTo      False otherwise) }

// ---------------------------
//  Jewel information
// ---------------------------
function hasJewel_(quell)      { return(not isNoJewel_(jewel(quell))) }
function jewelPosOn_(quell)    { return(jpos(jewel(quell)))           } /* PRECOND: * hasJewel_(quell) */     

// ---------------------------
//  Ball information
// ---------------------------
function hasBall_(quell)       { return(not isNoBall_(ball(quell))) }
function hasMovingBall_(quell) { return(isMovingBall_(ball(quell))) }
function ballPosOn_(quell)     { return(bpos(ball(quell)))          } /* PRECOND: * hasBall_(quell) */     
function ballDirOn_(quell)     { return(goingTo(ball(quel)))        } /* PRECOND: hasMovingBall_(quell) */ 
function ballBeamingOn_(quell) { return(beaming(ball(quel)))        } /* PRECOND: hasMovingBall_(quell) */ 
/* ============================================================================================================
   END Quell-Model.gbs
   ============================================================================================================
*/
/* ============================================================================================================
   START Quell-Operations.gbs
   Operations to perform a step of movement (with all the needed changes)
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
// REQUIRE: Quell-Representation.gbs
// REQUIRE: Quell-Drawing.gbs
// REQUIRE: Quell-Reading.gbs
   ============================================================================================================
*/
// ---------
// Quell I/O operations
// ---------
//function  currentQuell()    { return (currentQLevel()) } /* PRECOND: there is a quell level represented in the Gobstones board */
procedure DrawQuell_(quell) { DrawQLevel_(quell) }       /* PRECOND: Gobstones board is big enough to represent the quell board and the top bar */

{-
// ---------
// Quell movement operations
// ---------
procedure ProcessMoveTo_(dir) { AuxProcessMoveTo_(just(dir)) }
procedure ProcessMove()       { AuxProcessMoveTo_(Nothing)   }

procedure AuxProcessMoveTo_(mdir) {
  quell      := currentQuell()
  isTutorial := isTutorialLevel()
  newQuell   := quell_WithOneStepTo_(quell, mdir)
  MarkAsTutorial()
  AddBallVisualIndicationOn_(newQuell)
  WriteQuell_(newQuell)
//  AnalizeEndingOn_(newQuell)
}

// ---------
// Quell operative functions
// ---------
function quell_WithOneStepTo_(quell, mdir) {
  /* OBS: If the ball is moving, dir is ignored. If there is no ball, there is nothing to do. */
  newQuell := quell
  if (hasMovingQBall_(newQuell) || stepAt_StartsMoveTo_(newQuell, mdir)) {
    // Determine the direction of movement, and adjust solution if a movement starts
    if (hasMovingQBall_(newQuell)) 
      { dirOfMove := fromJust(dirOfBallOn_(newQuell)) }
    else
      { dirOfMove := fromJust(mdir)
        newQuell  := quell_WithAdjustedSolutionFor_(newQuell, dirOfMove)
      }

    let (curPos, curQE)   := currentDataOn_(newQuell)      
    let (nextPos, nextQE) := nextDataOn_From_To_(newQuell, curPos, dirOfMove)

   // COMPLETAR     
   //    If nextQE is a box, calculate its immediate next      
   // Mejorar el análisis de adjusted
   // let (dirOfMove, nextQE, nextPos) :=  adjusted_And_In_WRT_In_On_(dirOfMove, nextQE, nextPos, curQE, curPos, newQuell)
    
    action       := whatHappensIn_MovingTo_On_(nextQE, dirOfMove, newQuell)
    globalAction := globalActionFrom_On_(nextQE, newQuell)
    newQuell     := afterAction_On_With_At_And_At_To_(action, newQuell, curQE, curPos, nextQE, nextPos, dirOfMove)
    newQuell     := afterGlobal_On_(globalAction, newQuell)
  }
  return(newQuell)
}

function quell_WithAdjustedSolutionFor_(quell, dirOfMove) {
  /* PRECOND: there is a ball */
   newSolution := solution(quell)
   if (not isEmpty(newSolution) && head(newSolution) == dirOfMove)
        { newSolution := tail(newSolution) }
   else { newSolution := []                }
   return(QuellLevel(quell | solution <- newSolution, numMoves <- numMoves(quell) + 1))
}

// ---------
// Topological determination of data
// ---------
function currentDataOn_(quell) {
  pos := ballPosOn_(quell)
  return(pos, elemAtPos_In_(pos, board(quell)))
}

function nextDataOn_From_To_(quell, pos, dir) {
  /* PURPOSE: calculates the next position and element for balls AND boxes */
  let (nextPos, nextQE) := neighborDataOn_From_To_(quell, pos, dir)

  // The next of a limit is the next of the matching limit. This control has to be first, in case that next is a Portal
  if (isLimit_(nextQE)) {
    newPos  := matchingLimitFor_At_To_In_(nextQE, nextPos, dir, board(quell))
    nextPos := nextPosOf_To_(newPos, dir)      
    nextQE  := elemAtPos_In_(nextPos, board(quell))
  }

  // Entering a portal always ends in the target
  if (isPortal_(nextQE)) {
    nextPos := targetOf_From_(nextQE, nextPos)
    nextQE  := elemAtPos_In_(nextPos, board(quell))
  }

  return (nextPos, nextQE)
}

function neighborDataOn_From_To_(quell, pos, dir) {
  neighPos := nextPosOf_To_(pos, dir)
  return(neighPos, elemAtPos_In_(neighPos, board(quell)))
}

// ---------
// Other
// ---------
function adjusted_And_In_WRT_In_On_(dir, next, nextPos, current, curPos, quell) {
  /* OBS: the 3 checks are sequential to allow complex configurations (i.e. a portal besides another portal with a Limit besides its target) */
  curDir      := dir
  curlNextPos := nextPos
  curlNext    := next
  
  if (isPortal_(current) && isBlocking_(curNext) && not isDangerous_From_On_(curNext, curDir, quell)) {
    curDir     := opposite (curDir)
    newPos     := targetOf_From_(current, curPos)
    curNextPos := nextPosOf_To_(newPos, curDir)
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  }
  
  if (isPortal_(curNext)) {
    curNextPos := targetOf_From_(curNext, curNextPos)
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  } 

  if (isLimit_(curNext)) {
    newPos     := matchingLimitFor_At_To_In_(curNext, curNextPos, curDir, board(quell))
    curNextPos := nextPosOf_To_(newPos, curDir)      
    curNext    := elemAtPos_In_(curNextPos, board(quell))
  }
  
  return (curDir, curNext, curNextPos)
}

function whatHappensIn_MovingTo_On_(qelem, dir, quell) {
  return (choose Pop  when (isDangerous_From_On_(qelem, dir, quell))
                 Stay when (isBlocking_(qelem))
                 Move otherwise
  )
}

function globalActionFrom_On_(qelem, quell) {
  return (matching (qelem) select
            spikesDir(quell) on Switch
            Nothing          otherwise)
}

function afterAction_On_With_At_And_At_To_(action, quell, current, curPos, next, nextPos, dir) {
    switch (action) {
       Pop  -> { newQuell := QuellLevel(quell | inTransit <- Nothing, ball <- Nothing) }
       Stay -> { newQuell := QuellLevel(quell | inTransit <- Nothing)
                 newQuell := withAdjustedJewelAt_On_(nextPos, newQuell)
               }
       Move -> { newQuell := QuellLevel(quell| inTransit <- just(dir), ball <- just(nextPos))
                 newQuell := withNew_At_And_At_To_On_(current, curPos, next, nextPos, dir, newQuell)
                 newQuell := withAdjustedJewelAt_On_(nextPos, newQuell)
               }
     }
    return (newQuell)
}

function afterGlobal_On_(gaction, quell) {
    return (matching (gaction) select
              QuellLevel(quell | spikesDir <- fromJust(gaction)) on Just
              quell                                              otherwise)
}

function withNew_At_And_At_To_On_(current, curPos, next, nextPos, dir, quell) {
   newCurrent := elem_AfterLeaving(current)
   newNext    := elem_AfterEnterFrom_(next, dir)
   newBoard   := set_AtPos_To_(set_AtPos_To_(board(quell)
                                           , curPos, newCurrent)
                             , nextPos, newNext)
   return (QuellLevel(quell | board     <- newBoard
                            , numPearls <- adjustPearls(numPearls(quell), next))
      )
 }

function withAdjustedJewelAt_On_(pos, quell) {
  jewel    := jewel(quell)
  hits     := hitsReceived(jewel)
  newJewel := QJewel(jewel | hitsReceived <- (1+hits) mod 3
                          , found <- hits==2)
  return (choose QuellLevel (quell | jewel <- newJewel)  when (not found(jewel) && pos==jpos(jewel))
                 quell                                   otherwise)
}
           
function elem_AfterEnterFrom_(qelem, dir) {
  return (matching (qelem) select
            Empty on Pearl
            qelem otherwise)
}

function elem_AfterLeaving(qelem) {
  return (matching (qelem) select
            Gate(open <- False) on Gate
            qelem               otherwise
  )
}

function adjustPearls (num, qelem) {
  return(matching (qelem) select
           num-1 on Pearl
           num otherwise)
}

// ---------
// Basic Quell functions
// ---------
function stepAt_StartsMoveTo_(quell, mdir) { return (hasQBall_(quell) && not ballOn_IsMoving(quell) && not isNothing(mdir)) }

function isDangerous_From_On_(qelem, dir, quell) {
  return(matching (qelem) select
           dirOfSpikesOf_At_(qelem, quell)==opposite(dir) on Spike
           True                                           on Multispike
           False                                          otherwise)
}

function dirOfSpikesOf_At_(qelem, quell) {
  /* PRECOND: qelem is a Spike */
  return(choose spikesDir(quell)             when (isRotable_(qelem))
                fromJust(notRotable(qelem)) otherwise)
}

function isBlocking_(qelem) {
  return(matching (qelem) select
           True            on Wall
           True            on Spike
           True            on Multispike
           not open(qelem) on Gate
           False           otherwise)
}

function targetOf_From_(qportal, pos) {
  /* PRECOND: * qportal is a Portal */
 return (choose doorA(qportal) when (doorB(qportal)==pos)
                doorB(qportal) when (doorA(qportal)==pos)
                pos            otherwise)
}

// ---------
// Functions for Limits
// ---------
function matchingLimitFor_At_To_In_(qelem, pos, dir, board) {
  /* PRECOND:
       * the qelem in board at pos is a Limit pointing to other limit
       * board is the board of a valid QLevel
  */
 return(choose
          Pos (row <- row(pos)
              ,col <- indexOfLimitNotAt_In_(col(pos), elemAtIndex_In_(row(pos), board)))    when (isHorizontal(dir)) 
          Pos (row <- indexOfLimitNotAt_In_(row(pos), column_Of_(col(pos)     , board))
              ,col <- col(pos))                                                             otherwise)
}

function indexOfLimitNotAt_In_(idx, qs) {
  /* PRECOND: * there are at least two Limits in qs pointing to each other, one of them at pos */
  let (before, qelem, after) := split_At_(qs, idx)
  Assert_OrFail_ (isLimit_(qelem), msgNotALimit())
  if (pointsBackwards_(qelem)) 
       { let (matchingIdx, matchingQE) := firstLimitBackwardsIn_(before)
         Assert_OrFail_(pointsForwards_(matchingQE), msgMalformedBoard())
       }
  elseif (pointsForwards_(qelem)) 
       { let (matchingIdx, matchingQE) := firstLimitForwardsIn_(after)
         Assert_OrFail_(pointsBackwards_(matchingQE), msgMalformedBoard())
         matchingIdx := matchingIdx + idx + 1
       }
  else { BOOM(msgNotABorder()) }
  return(matchingIdx)
}

function pointsBackwards_(qelem) {
  dir := pointsTo(qelem)
  return(dir == just(South) || dir == just(West))
}

function pointsForwards_(qelem) {
  dir := pointsTo(qelem)
  return(dir == just(North) || dir == just(East))
}

function firstLimitBackwardsIn_(qs) {
  /* PRECOND: qs has a Limit */
  let (idx, qelem) := firstLimitForwardsIn_(reverse(qs))
  return (idx+lengthOf_(qs)-1, qelem)
}

function firstLimitForwardsIn_(qs) {
  /* PRECOND: qs has a Limit */
   idx     := 0
   qelem   := head(qs)
   current := tail(qs)
   while(not isLimit_(qelem)) {
     idx     := idx + 1
     qelem   := head(current)
     current := tail(current)
   }
   return(idx, qelem)
}

// ---------
// Error messages
// ---------
function msgMalformedBoard() { return(babel("Malformed board", "Tablero mal formado"))          }
function msgNotALimit()      { return(babel("QElement at the given position is not a Limit"
                                          , "El QElement en la posición dada no es un Límite")) }
function msgNotABorder()     { return(babel("Limit at the given position is not a border"
                                          , "El Límite en la posición dada no es un borde"))    }
-}
/* ============================================================================================================
   END Quell-Operations.gbs
   ============================================================================================================
*/
{-
/* ============================================================================================================
   START Quell-Reading.gbs
   Operations to read a Quell level from the board
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
// REQUIRE: Quell-Representation.gbs
   ============================================================================================================
*/

// ---------
// Reading operations
// OBS: All operations has as PRECOND:
//        * there is a quell level represented in the Gobstones board 
// ---------
function currentQLevel() {
  let (curSpikesDir, curNumMoves, curMinMoves
      ,curJewelPos, curJewelFound, curSolution
      ,curNumPearls)                         := currentQInfo()
  let (curBoard, checkNumPearls)             := currentQBoard()
  let (curBallMPos, curBallMDir)             := currentQBallInfo()
  curJewelInfo                               := currentQJewel(curJewelFound, curJewelPos)
  Assert_OrFail_(curNumPearls==checkNumPearls, msgInvalidQuellOnTheBoard())
  return (QuellLevel(board     <- curBoard
                   , spikesDir <- curSpikesDir
                   , jewel     <- curJewelInfo
                   , ball      <- curBallMPos
                   , inTransit <- curBallMDir
                   , numPearls <- curNumPearls
                   , solution  <- curSolution
                   , minMoves  <- curMinMoves
                   , numMoves  <- curNumMoves))
}

// Level 1
function currentQInfo() {
  GoToTopRow()
  Assert_OrFail_(isCellAtTopRow(), msgNoQuellLevel())
  curSpikesDir  := currentMDirWith_(attrAColor())  Move(East)
  curNumMoves   := currentNumWith_(attrAColor())   Move(East)
  curMinMoves   := currentNumWith_(attrAColor())   Move(East)
  curJewelPos   := currentPosWith_(attrAColor())   Move(East)
  curSolution   := currentDirsWith_And_(attrAColor(), attrBColor())
  GoToEdge(East)                                   Move(West)
  curNumPearls  := currentNumWith_(attrAColor())   Move(West)
  curJewelFound := currentBoolWith_(attrBColor())
  return (curSpikesDir, curNumMoves, just(curMinMoves), curJewelPos, curJewelFound, curSolution, curNumPearls)
}

function currentQBoard() {
  GoToCorner__(South,East)
  curBoard     := [ ]
  curNumPearls := 0
  while (not atTopRow()) {
    let (row, numPearls) := currentRowInfo()
    curBoard     := curBoard ++ [ row ]
    curNumPearls := curNumPearls + numPearls
    Move(North)
  } 
  return(curBoard, curNumPearls)
}

function currentQBallInfo() {
  GoToBall()
  NormalizeBallIfNeeded()
  return(choose (just(currentPos()), currentMDirWith_(ballColor())) when (hasBall())
                (Nothing           , Nothing)                       otherwise)
}

function currentQJewel(found, jpos) {
  /* PRECOND: * there is a jewel represented in the board */
  GoToCell_(jpos)
  return(QJewel(found        <- found
              , jpos         <- jpos
              , hitsReceived <- numStones(attrAColor())-1))
}

// Level 2
procedure GoToBall() {
  StartBoardTraverseTo_And_(East, North)
  while(not atEndOfBoardTraverseTo_And_(East, North) 
     && not hasBall()) {
    GoToNextCellInBoardTraverseTo_And_(East, North) 
  }
}

procedure NormalizeBallIfNeeded() {
  if (ballIndicatesDirectionVisually()) { RemoveBallVisualIndication() }
}

function currentRowInfo() {
  GoToEdge(West)
  qelem := currentQElem()
  curRow       := [ qelem ]
  curNumPearls := delta(isPearl_(qelem))
  while (canMove(East)) {
     Move(East)
     qelem := currentQElem()
     curRow       := curRow ++ [ qelem ]
     curNumPearls := curNumPearls + delta(isPearl_(qelem))
  }
  return (curRow, curNumPearls)
}

function currentQElem() {
  /* PRECOND: * there is a qelem represented in the current cell */
  
  return(matching (numStones(qelemColor())) select
          Empty                 on 0
          Pearl                 on 1
          Wall                  on 2
          currentBox()          on 3
          currentLimit()        on 4
          currentPortal()       on 5
          Multispike            on 6
          currentSpike()        on 7
          currentSwitch()       on 8
          currentGate()         on 9
          Out                   on 10
          boom(msgNoQElement()) otherwise)
}

function currentBox() {
  /* PRECOND: * there is a box represented in the current cell */
  return(Box(gender <- currentGenderWith_(attrAColor())))
}

function currentLimit() {
  /* PRECOND: * there is a limit represented in the current cell */
  return(Limit(corner   <- currentCornerWith_(attrAColor())
             , pointsTo <- currentMDirWith_(attrBColor())))
}

function currentPortal() {
  /* PRECOND: * there is a portal represented in the current cell */
  return(Portal(doorA <- currentPosWith_(attrAColor())
              , doorB <- currentPosWith_(attrBColor())))
}

function currentSpike() {
  /* PRECOND: * there is a spike represented in the current cell */
  return(Spike(notRotable <- currentMDirWith_(attrAColor())))
}

function currentSwitch() {
  /* PRECOND: * there is a switch represented in the current cell */
  return(Switch)
}

function currentGate() {
  /* PRECOND: * there is a gate represented in the current cell */
  return(Gate(open <- currentBoolWith_(attrAColor())))
}

function currentCornerWith_(color) { 
  code := numStones(color)
  if (num_IsBetween_And_(code, 1, 4)) 
    { d1 := decodedDir_(code) 
      d2 := nextDir(d1)   
  } elseif (num_IsBetween_And_(code, 5, 8)) 
    { d1 := decodedDir_(code-4)
      d2 := prevDir(d1)   
  } else { }                                      
  return(choose just((d1,d2)) when (num_IsBetween_And_(code, 1, 8))
                Nothing       otherwise)
}

function currentDirsWith_And_(colorA, colorB) {
  code := currentCodeInBase_With_And_(100, colorA, colorB)
  return(decodedDirs_(code))
}

function currentCodeInBase_With_And_(base, colorA, colorB) {
  currentColor := colorA
  currentCode  := 0
  currentPow   := 1
  while (hasStones(colorA)) {
    currentDigit := currentNumWith_(currentColor)
    currentCode  := currentCode + currentDigit * currentPow
    currentPow   := currentPow * base
    if (currentColor == colorA) { currentColor := colorB            } 
     else                       { currentColor := colorA Move(East) }
  }
  return(currentCode)
}

function hasBall()   { return(num_IsBetween_And_(numStones(ballColor()), 1, 9))     }
function hasQJewel() { return((hasWall() || hasEmpty()) && hasStones(attrAColor())) }
function hasWall()   { return(numStones(qelemColor())==2)                           }
function hasEmpty()  { return(numStones(qelemColor())==0)                           }

// ---------
// Tutorial operations
// ---------
procedure MarkAsTutorial() {
  ClearBoard()
  GoToCorner__(South, West)
  Drop(attrBColor())
}

function isTutorialLevel() {
  GoToCorner__(South, West)
  return(hasStones(attrBColor()))
}

procedure AddBallVisualIndicationOn_(quell) {
  if (hasQBall_(quell) && not hasMovingQBall_(quell) && not isEmpty(solution(quell)) ) {
    GoToCell_(ballPosOn_(quell))
    AddBallVisualIndicationTo_(head(solution(quell)))
  }
}

function  ballIndicatesDirectionVisually() { return(num_IsBetween_And_(numStones(ballColor()), 6, 9)) }
procedure RemoveBallVisualIndication() { 
  /* PRECOND: there is a ball with visual indication (there are between 6 and 9 stones) in the current cell */
  Grab__Times(ballColor(), numStones(ballColor())-5) 
}
procedure AddBallVisualIndicationTo_(dir) { 
  /* PRECOND: there is a ball that is not moving and without visual indication (there are 5 stones) in the current cell */
  Drop__Times(ballColor(), codeOfDir_(dir)) 
}

// ---------
// Error messages
// ---------
function msgNoQuellLevel() { 
  return(babel("There is no Quell level represented on the board"
              ,"No hay un nivel de Quell representado en el tablero"))
}

function msgNoQElement() { 
  return(babel("There is no QElement represented in the current cell"
              ,"No hay un QElement representado en la celda actual"))
}

function msgInvalidQuellOnTheBoard() { 
  return(babel("Quell representation on the board is invalid"
              ,"La representación de Quell en el tablero es inválida"))
}
/* ============================================================================================================
   END Quell-Reading.gbs
   ============================================================================================================
*/
-}/* ============================================================================================================
   START Quell-Representation.gbs
   Coding colors and explanation of representation for QuellLevels
// REQUIRE: Babel.gbs
// REQUIRE: EnglishPrimitives.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: Quell-Model.gbs
   ============================================================================================================
*/

// ---------
// Representation
// ---------
/*
  QLevel info is represented at top row with 10x qelem stones (x the col Number) 
    * cell  1 at column 1 encode numMoves in attrA stones (100 for overload)
    * cell  2 at column 2 encode minMoves in attrA stones (up to 29 -- more are ignored)
    * cell  3 at column 2 from East encode jewelFound in attrB stones
                                       and jewel existance in attrA stones
    * cell  4 at column 1 from East encode numPearls in attrA stones
                                       and numRightMoves in attrB stones
    * cell  0 at East edge encode spikesDir in attrA stones

  QElements are represented with qelemColor() stones, and their attributes with attrAColor() and attrBColor() stones, depending of the case.
    + Empty       ,  no qelem stones
    + Corner      ,  1 stone   * dir     , attrA stones
    + Angle       ,  2 stones  * dir     , attrA stones
    + Limit       ,  3 stones  * pointsTo, attrA stones 
    + Portal      ,  4 stones  * target  , attrA stones
                               * id      , attrB stones
    + Gate        ,  5 stones  * open    , attrB stones
    + Switch      ,  6 stones  * spikesDir, attrA stones
    + Rotablespike,  7 stones  * spikesDir, attrA stones
    + Spike       ,  8 stones  * dir     , attrA stones 
    + Multispike  ,  9 stones
    + Wall        , 10 stones
    + Out         , 11 stones

    + Pearl                    *       1 attrB stones (to avoid clashes with Boxes)
    + Box                      * gender, 10*attrB stones (must be equal to Pearl representation, and different from attributes at Gates, Portals or Switches)
    + Jewel                    * hits  , attrA stones (must be different from Pearl representation, because it may also appear on Empty)
  
  The ball is represented with ballColor() stones 
    + moving North                 ,  1 stone
    + moving East                  ,  2 stones
    + moving South                 ,  3 stones
    + moving West                  ,  4 stones
    + not moving                   ,  5 stones
    + not moving with hint to North,  6 stones (5+1)
    + not moving with hint to East ,  7 stones (5+2)
    + not moving with hint to South,  8 stones (5+3)
    + not moving with hint to West ,  9 stones (5+4)
    + beaming while moving North   , 11 stones (10+1)
    + beaming while moving East    , 12 stones (10+2)
    + beaming while moving South   , 13 stones (10+3)
    + beaming while moving West    , 14 stones (10+4)
*/

// ---------
// Colors
// ---------
function ballColor()  { return(Blue)  }
function qelemColor() { return(Black) }
function attrAColor() { return(Green) }
function attrBColor() { return(Red)   }

// ---------
// Codes
// ---------
function codeOfQelem_(qelem) {
  return (matching (qelem) select
             0 on Empty
             0 on Pearl   // Pearls are always on Empty cells, and drawn with attribute colors
             1 on Corner
             2 on Angle
             3 on Limit
             4 on Portal
             5 on Gate
             6 on Spike
             7 on Multispike
             8 on RotableSpike
             9 on Switch
            10 on Wall
            11 on Out
            boom(msgNotExpected("QElem")) otherwise
  )
}
/* ============================================================================================================
   END Quell-Representation.gbs
   ============================================================================================================
*/
