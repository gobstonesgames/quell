/* ============================================================================================================
   START Quell-IO.gbs
   Operations to draw and read a Quell level from the board
// REQUIRE: Babel.gbs
// REQUIRE: Prelude.gbs
// REQUIRE: QuellRepresentation.gbs
   ============================================================================================================
*/

// ---------
// Quell I/O operations
// ---------
function currentQuell() {
  /* PRECOND: * there is a quell level represented in the Gobstones board */
  return (currentQLevel())
}

procedure WriteQuell_(quell) {
  /* PRECOND: * Gobstones board is big enough to represent the quell board */
  DrawQLevel_(quell)
}

// ---------
// Representation
// ---------
/*
  The ball is represented with ballColor() stones (standard representation for MDir:, 1 to 5 stones:
    + moving North, 1 stone
    + moving East,  2 stones
    + moving South, 3 stones
    + moving West,  4 stones
    + not moving,   5 stones)
     
   QElements are represented with qelemColor() stones, and their attributes with attrAColor() and attrBColor() stones, depending of the case.
    + Empty, no qelem stones
    + Pearl,      1 stone
    + Wall,       2 stones
    + Box,        3 stones
    + Limit,      4 stones
                     * isCorner, attrA stones (1-4 for corners, 5-8 for angles)
                     * pointsTo, attrB stones 
    + Portal, 5 stones
                     * doorA,    attrA stones
                     * doorB,    attrB stones
    + Multispike, 6 stones
    + Spike,      7 stones
                     * rotable,  attrA stones 
    + Switch,     8 stones
    + Gate,       9 stones
                     * open,     attrA stones
    + Out,       10 stones (or 110 for special case)
  
   QLevel info is represented at SouthWestWest corner with 110 qelem stones and 
    + attrA stones to indicate minMoves of the level
    + attrB stones to indicate if jewel was found
    + the field spikesDir is indicated with attrA stones at all Switches, if it is different from Nothing

  The jewel is represented on its position if it was not found, using
    + hitsReceived, attrA stones
*/

// ---------
// Reading operations
// OBS: All operations has as PRECOND:
//        * there is a quell level represented in the Gobstones board 
// ---------
function currentQLevel() {
  let (curMinMoves, found)                   := currentQInfo()
  let (curBoard, curNumPearls, curSpikesDir) := currentQBoard()
  let (curBallMPos, curBoardMDir)            := currentQBallInfo()
  curJewelInfo                               := currentQJewel(found)
  return (QuellLevel(board     <- curBoard
                   , ball      <- curBallMPos
                   , inTransit <- curBoardMDir
                   , numPearls <- curNumPearls
                   , minMoves  <- curMinMoves
                   , spikesDir <- curSpikesDir
                   , jewel     <- curJewelInfo))
}

// Level 1
function currentQInfo() {
  GoToCorner__(South, West)
  Assert_OrFail_(numStones(qelemColor()) == 110, msgNoQuellLevel())
  curMinMoves := currentMNumWith_(attrAColor())
  found       := currentBoolWith_(attrBColor())
  return (curMinMoves, found)
}

function currentQBoard() {
  GoToCorner__(South,East)
  let (curBoard, curNumPearls, curSpikesDir) := currentRowInfo()
  while (canMove(North)) {
    Move(North)
    let (rows, numPearls, newSpikesDir) := currentRowInfo()
    curSpikesDir := firstOf_Or_(curSpikesDir, newSpikesDir)
    curBoard     := rows ++ curBoard
    curNumPearls := curNumPearls + numPearls
  } 
  return(curBoard, curNumPearls, curSpikesDir)
}

function currentQBallInfo() {
  GoToBall()
  return(choose (just(currentPos()), currentMDirWith_(ballColor())) when (hasBall())
                (Nothing           , Nothing)                       otherwise)
}

function currentQJewel(found) {
  /* PRECOND: * there is a jewel represented in the board */
  GoToQJewel()
  return(QJewel(found        <- found
              , jpos          <- currentPos()
              , hitsReceived <- numStones(attrAColor())-1))
}

// Level 2
procedure GoToBall() {
  StartBoardTraverseTo_And_(East, North)
  while(not atEndOfBoardTraverseTo_And_(East, North) 
     && not hasBall()) {
    GoToNextCellInBoardTraverseTo_And_(East, North) 
  }
}

procedure GoToQJewel() {
  StartBoardTraverseTo_And_(East, North)
  while(not atEndOfBoardTraverseTo_And_(East, North) 
     && not hasQJewel()) {
    GoToNextCellInBoardTraverseTo_And_(East, North) 
  }
}

function currentRowInfo() {
  GoToEdge(West)
  let (qelem, curSpikesDir) := currentQElem()
  curRow       := [ qelem ]
  curNumPearls := delta(isPearl_(qelem))
  while (canMove(East)) {
     Move(East)
     let (qelem, newSpikesDir) := currentQElem()
     curSpikesDir := firstOf_Or_(curSpikesDir, newSpikesDir)
     curRow       := [ qelem ] ++ curRow
     curNumPearls := curNumPearls + delta(isPearl_(qelem))
  }
  return ([ curRow ], curNumPearls, curSpikesDir)
}

function currentQElem() {
  /* PRECOND: * there is a qelem represented in the current cell */
  
  return(matching (numStones(qelemColor())) select
          Empty                 on 0
          Pearl                 on 1
          Wall                  on 2
          currentBox()          on 3
          currentLimit()        on 4
          currentPortal()       on 5
          Multispike            on 6
          currentSpike()        on 7
          currentSwitch()       on 8
          currentGate()         on 9
          Out                   on 10
          Out                   on 110
          boom(msgNoQElement()) otherwise 
      , choose currentMDirWith_(attrAColor()) when (numStones(qelemColor()) == 7) 
               Nothing                        otherwise)
}

function currentBox() {
  /* PRECOND: * there is a box represented in the current cell */
  return(Box(gender <- currentGenderWith_(attrAColor())))
}

function currentLimit() {
  /* PRECOND: * there is a limit represented in the current cell */
  return(Limit(corner   <- currentCornerWith_(attrAColor())
             , pointsTo <- currentMDirWith_(attrBColor())))
}

function currentPortal() {
  /* PRECOND: * there is a portal represented in the current cell */
  return(Portal(doorA <- currentPosWith_(attrAColor())
              , doorB <- currentPosWith_(attrBColor())))
}

function currentSpike() {
  /* PRECOND: * there is a spike represented in the current cell */
  return(Spike(notRotable <- currentMDirWith_(attrAColor())))
}

function currentSwitch() {
  /* PRECOND: * there is a switch represented in the current cell */
  return(Switch)
}

function currentGate() {
  /* PRECOND: * there is a gate represented in the current cell */
  return(Gate(open <- currentBoolWith_(attrAColor())))
}

function currentCornerWith_(color) { 
  code := numStones(color)
  return(choose Nothing             when (code==9)
                decodedDir_(code-4) when (num_IsBetween_And_(code, 5, 8))
                decodedDir_(code)   otherwise)
}

function hasBall()   { return(num_IsBetween_And_(numStones(ballColor()), 1, 5))     }
function hasQJewel() { return((hasWall() || hasEmpty()) && hasStones(attrAColor())) }
function hasWall()   { return(numStones(qelemColor())==2)                           }
function hasEmpty()  { return(numStones(qelemColor())==0)                           }

// ---------
// Drawing operations
// ---------
procedure DrawQLevel_(quell) {
  ClearBoard()
  DrawQInfo_(quell)
  DrawQBoard_WithSpikesTo_(board(quell), spikesDir(quell))
  DrawQJewel_(jewel(quell))
  DrawQBall_To_(ball(quell), inTransit(quell))
}

// Level 1
procedure DrawQInfo_(quell) {
  GoToCorner__(South, West)
  Drop__Times(qelemColor(), 100)
  DrawMNum_With_(minMoves(quell), attrAColor())
  DrawBool_With_(found(jewel(quell)), attrBColor())
}

procedure DrawQBoard_WithSpikesTo_(board, spikesDir) {
  /* PRECOND: * the board has at least one qelem */
  GoToCorner__(South, West)
  curBoard := reverse(board)
  DrawQRow_WithSpikesTo_(head(curBoard), spikesDir)
  foreach row in tail(curBoard) {
    Move(North)
    DrawQRow_WithSpikesTo_(row, spikesDir)
  }
}

procedure DrawQBall_To_(ball, mdir) {
   if (not isNothing(ball)) {
     pos := fromJust(ball)
     GoToCell_(pos)
     DrawBall_(mdir)
   }
}

procedure DrawQJewel_(jewel) {
  GoToCell_(jpos(jewel))
  Drop__Times(attrAColor(), 1+hitsReceived(jewel))
  DrawBool_With_(found(jewel), attrBColor())
}

// Level 2
procedure DrawBall_(mdir) {
  DrawMDir_With_(mdir, ballColor())
}

procedure DrawQRow_WithSpikesTo_(row, spikesDir) {
  /* PRECOND: * the row has at least one element */
  GoToEdge(West)
  DrawQelem_WithSpikesTo_(head(row), spikesDir)
  foreach qelem in tail(row) {
    Move(East)
    DrawQelem_WithSpikesTo_(qelem, spikesDir)  
  }
}

procedure DrawQelem_WithSpikesTo_(qelem, spikesDir) {
  Drop__Times(qelemColor(), codeOfQelem_(qelem))
  switch (qelem) to {
    Box(gender)             -> { DrawGender_With_(gender   , attrAColor()) }
    Limit(corner, pointsTo) -> { DrawCorner_With_(corner   , attrAColor())
                                 DrawMDir_With_  (pointsTo , attrBColor()) }
    Portal(doorA, doorB)    -> { DrawPos_With_   (doorA    , attrAColor())
                                 DrawPos_With_   (doorB    , attrBColor()) }
    Spike(rotable)          -> { DrawMDir_With_  (rotable  , attrAColor()) }
    Switch()                -> { DrawMDir_With_  (spikesDir, attrAColor()) }
    Gate(open)              -> { DrawBool_With_  (open     , attrAColor()) }
    _                       -> { }
    }
}

procedure DrawCorner_With_(corner, color) {
  switch (corner) to {
    Nothing    -> { Drop__Times(color, 9) }
    Just(d1d2) -> { d1 := fst(d1d2)
                    d2 := snd(d1d2)
                    if     (d2==nextDir(d1)) { DrawDir_With_(d1,color)              }
                    elseif (d2==prevDir(d1)) { Drop__Times(color, 4+codeOfDir_(d1)) }
                    else                     { BOOM(msgInvalidQuell())              }
                  }
  }
}

// ---------
// Codes
// ---------
function codeOfQelem_(qelem) {
  return (matching (qelem) select
             0 on Empty
             1 on Pearl
             2 on Wall
             3 on Box
             4 on Limit
             5 on Portal
             6 on Multispike
             7 on Spike
             8 on Switch
             9 on Gate
            10 on Out
            boom(msgNotExpected("QElem")) otherwise
  )
}

// ---------
// Colors
// ---------
function ballColor()  { return(Blue)  }
function qelemColor() { return(Black) }
function attrAColor() { return(Red)   }
function attrBColor() { return(Green) }

// ---------
// Error messages
// ---------
function msgNoQuellLevel() { 
  return(babel("There is no Quell level represented on the board"
              ,"No hay un nivel de Quell representado en el tablero"))
}

function msgNoQElement() { 
  return(babel("There is no QElement represented in the current cell"
              ,"No hay un QElement representado en la celda actual"))
}

function msgInvalidQuell() { 
  return(babel("Quell representation is invalid"
              ,"La representación de Quell es inválida"))
}

/* ============================================================================================================
   END Quell-IO.gbs
   ============================================================================================================
*/
