/* ============================================================================================================
   START QuellRepresentation.gbs
   Definition of the datatypes representing a Quell level
// REQUIRE: Babel.gbs
// REQUIRE: Prelude.gbs
   ============================================================================================================
*/

type QuellLevel is record {
  /* INV.REP.:
       * board represent a Quell level
           - all elements of the list at field board are lists of the same length
           - all rows or columns that have some element diferent of Out have at least 2 Limits pointing to each other (no other limit in between 2 pointing limits), and all elements different from Out in between a pair of pointing limits, and no Out elements are in between a pair of pointing limits
           - if the ball field is Just(fromJust<-pos), then the element at pos in board is either Empty or an open Gate or a Portal or a Switch, and pos is between Limits pointing to each other
           - the inTransit field is Just(dirOfMove) iff ball is not Nothing and the QElem in the next position in the dirOfBoard (see nextPos) is not a blocking element, that is:
               + a Wall, or 
               + a Spike pointing at opposite(dirOfMove), or 
               + a closed Gate
               + a blocked Box
           - all doors of Portals are valid positions in the board
           - every QElem equal to a Portal is placed at one of its doors' position, and in the other position there is also a Portal with matching doors
           - all Switches have the same value in their dir fields
           - all Spikes that have the  rotable field in True, have the same value for their dir field, and it is the same value than the dir field in all Switches
       * numPearls is equal to the number of pearls in the board
       * minMoves is the minimum number of moves required to solve the level using Quell rules (Nothing if not solvable)
       * the pos at field jewel indicates a valid position in the given board, and the QElem in that position is either Wall or Empty
       * the QElem at SouthWest corner of the board is Out (for drawing information about the level)
       * either there is any rotable spikes, at least a Switch, and spikeDir should be different from Nothing, 
             or there is no rotable spikes, no Switches, and spikeDir is Nothing
   */
   field board     // [[QElem]] 
   field ball      // Maybe(Pos)
   field inTransit // Maybe(Dir)
   field numPearls // Number
   field minMoves  // Maybe(Number)
   field spikesDir // Maybe(Direction)
   field jewel     // QJewel
}

type QElem is variant {
   case Empty      {}
   case Pearl      {}
   case Wall       {}
   case Box        { field gender }     // Gender
   case Limit      { field corner       // Maybe((Dir, Dir))
                     field pointsTo     // Maybe(Dir)
                   }
   case Portal     { field doorA        // Pos
                     field doorB        // Pos
                   }
   case Multispike {}
   case Spike      { field notRotable } // Maybe(Dir)
   case Switch     { } 
   case Gate       { field open }       // Bool
   case Out        {}
}

type QJewel is record {
   field jpos         // Pos
   field hitsReceived // Number 
   field found        // Bool
}

type BallAction is variant {
  case Move {}
  case Stay {}
  case Pop  {}
}

// ---------------------------
//  Abbreviations
// ---------------------------
function cNW()     { return(Limit(corner   <- just((East , South)), pointsTo <- Nothing))   }
function cNE()     { return(Limit(corner   <- just((South, West )), pointsTo <- Nothing))   }
function cSE()     { return(Limit(corner   <- just((West , North)), pointsTo <- Nothing))   }
function cSW()     { return(Limit(corner   <- just((North, East )), pointsTo <- Nothing))   }

function cNW_(dir) { return(Limit(corner   <- just((East , South)), pointsTo <- just(dir))) }
function cNE_(dir) { return(Limit(corner   <- just((South, West )), pointsTo <- just(dir))) }
function cSE_(dir) { return(Limit(corner   <- just((West , North)), pointsTo <- just(dir))) }
function cSW_(dir) { return(Limit(corner   <- just((North, East )), pointsTo <- just(dir))) }

function aNW()     { return(Limit(corner   <- just((South, East )), pointsTo <- Nothing))   }
function aNE()     { return(Limit(corner   <- just((West , South)), pointsTo <- Nothing))   }
function aSE()     { return(Limit(corner   <- just((North, West )), pointsTo <- Nothing))   }
function aSW()     { return(Limit(corner   <- just((East , North)), pointsTo <- Nothing))   }

function aNW_(dir) { return(Limit(corner   <- just((South, East )), pointsTo <- just(dir))) }
function aNE_(dir) { return(Limit(corner   <- just((West , South)), pointsTo <- just(dir))) }
function aSE_(dir) { return(Limit(corner   <- just((North, West )), pointsTo <- just(dir))) }
function aSW_(dir) { return(Limit(corner   <- just((East , North)), pointsTo <- just(dir))) }

function lH_(dir)   { return(Limit(corner   <- Nothing    , pointsTo <- just(dir))) }
function lV_(dir)   { return(Limit(corner   <- Nothing    , pointsTo <- just(dir))) }

// ---------------------------
//  Detection functions
// ---------------------------
function isEmpty_(qelem)      { return(matching (qelem) select True  on Empty       False otherwise) }
function isPearl_(qelem)      { return(matching (qelem) select True  on Pearl       False otherwise) }
function isWall_(qelem)       { return(matching (qelem) select True  on Wall        False otherwise) }
function isBox_(qelem)        { return(matching (qelem) select True  on Box         False otherwise) }
function isLimit_(qelem)      { return(matching (qelem) select True  on Limit       False otherwise) }
function isPortal_(qelem)     { return(matching (qelem) select True  on Portal      False otherwise) }
function isMultispike_(qelem) { return(matching (qelem) select True  on Multispike  False otherwise) }
function isSpike_(qelem)      { return(matching (qelem) select True  on Spike       False otherwise) }
function isSwitch_(qelem)     { return(matching (qelem) select True  on Switch      False otherwise) }
function isGate_(qelem)       { return(matching (qelem) select True  on Gate        False otherwise) }
function isOut_(qelem)        { return(matching (qelem) select True  on Out         False otherwise) }

function isRotableSpike(qelem) {
  return(matching (qelem) select 
           isRotable_(qelem) on Spike
           False             otherwise)
}

function isRotable_(qelem) {
  /* PRECOND: qelem is a Spike */
   return(notRotable(qelem)==Nothing)
}

// ---------------------------
//  Ball information
// ---------------------------
function dirOfBallOn_(quell)    { return(inTransit(quell))                           }
function hasQBall_(quell)       { return(not isNothing(ball(quell)))                 }
function hasMovingQBall_(quell) { return(hasQBall_(quell) && ballAt_IsMoving(quell)) }
function ballOn_IsMoving(quell) { return(not isNothing (inTransit(quell)))           }

function ballPosOn_(quell) {
  /* PRECOND: * there is a Ball in quell (ball(quell) is not Nothing) */
  return (fromJust(ball(quell)))
}
/* ============================================================================================================
   END QuellRepresentation.gbs
   ============================================================================================================
*/
